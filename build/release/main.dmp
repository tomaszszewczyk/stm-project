
main.elf:     file format elf32-littlearm


Disassembly of section .text:

08000110 <__do_global_dtors_aux>:
 8000110:	b510      	push	{r4, lr}
 8000112:	4c05      	ldr	r4, [pc, #20]	; (8000128 <__do_global_dtors_aux+0x18>)
 8000114:	7823      	ldrb	r3, [r4, #0]
 8000116:	b933      	cbnz	r3, 8000126 <__do_global_dtors_aux+0x16>
 8000118:	4b04      	ldr	r3, [pc, #16]	; (800012c <__do_global_dtors_aux+0x1c>)
 800011a:	b113      	cbz	r3, 8000122 <__do_global_dtors_aux+0x12>
 800011c:	4804      	ldr	r0, [pc, #16]	; (8000130 <__do_global_dtors_aux+0x20>)
 800011e:	f3af 8000 	nop.w
 8000122:	2301      	movs	r3, #1
 8000124:	7023      	strb	r3, [r4, #0]
 8000126:	bd10      	pop	{r4, pc}
 8000128:	2000002c 	.word	0x2000002c
 800012c:	00000000 	.word	0x00000000
 8000130:	08002060 	.word	0x08002060

08000134 <frame_dummy>:
 8000134:	4b0c      	ldr	r3, [pc, #48]	; (8000168 <frame_dummy+0x34>)
 8000136:	b143      	cbz	r3, 800014a <frame_dummy+0x16>
 8000138:	480c      	ldr	r0, [pc, #48]	; (800016c <frame_dummy+0x38>)
 800013a:	b510      	push	{r4, lr}
 800013c:	490c      	ldr	r1, [pc, #48]	; (8000170 <frame_dummy+0x3c>)
 800013e:	f3af 8000 	nop.w
 8000142:	480c      	ldr	r0, [pc, #48]	; (8000174 <frame_dummy+0x40>)
 8000144:	6803      	ldr	r3, [r0, #0]
 8000146:	b923      	cbnz	r3, 8000152 <frame_dummy+0x1e>
 8000148:	bd10      	pop	{r4, pc}
 800014a:	480a      	ldr	r0, [pc, #40]	; (8000174 <frame_dummy+0x40>)
 800014c:	6803      	ldr	r3, [r0, #0]
 800014e:	b933      	cbnz	r3, 800015e <frame_dummy+0x2a>
 8000150:	4770      	bx	lr
 8000152:	4b09      	ldr	r3, [pc, #36]	; (8000178 <frame_dummy+0x44>)
 8000154:	2b00      	cmp	r3, #0
 8000156:	d0f7      	beq.n	8000148 <frame_dummy+0x14>
 8000158:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800015c:	4718      	bx	r3
 800015e:	4b06      	ldr	r3, [pc, #24]	; (8000178 <frame_dummy+0x44>)
 8000160:	2b00      	cmp	r3, #0
 8000162:	d0f5      	beq.n	8000150 <frame_dummy+0x1c>
 8000164:	4718      	bx	r3
 8000166:	bf00      	nop
 8000168:	00000000 	.word	0x00000000
 800016c:	08002060 	.word	0x08002060
 8000170:	20000030 	.word	0x20000030
 8000174:	2000002c 	.word	0x2000002c
 8000178:	00000000 	.word	0x00000000

0800017c <task1>:
void Delay(vu32 nCount);

/* Private functions ---------------------------------------------------------*/

void task1( void *pvParameters )
{
 800017c:	b508      	push	{r3, lr}
  while (1)
  {
    /* Turn on led connected to PC.4 pin */
    GPIO_SetBits(GPIOA, GPIO_Pin_1);
 800017e:	4c09      	ldr	r4, [pc, #36]	; (80001a4 <task1+0x28>)
 8000180:	2102      	movs	r1, #2
 8000182:	4620      	mov	r0, r4
 8000184:	f000 f98b 	bl	800049e <GPIO_SetBits>
    /* Insert delay */
    vTaskDelay(pdMS_TO_TICKS(500));
 8000188:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800018c:	f001 f8a8 	bl	80012e0 <vTaskDelay>

    /* Turn off led connected to PC.4 pin */
    GPIO_ResetBits(GPIOA, GPIO_Pin_1);
 8000190:	4620      	mov	r0, r4
 8000192:	2102      	movs	r1, #2
 8000194:	f000 f985 	bl	80004a2 <GPIO_ResetBits>
    /* Insert delay */
    vTaskDelay(pdMS_TO_TICKS(500));
 8000198:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800019c:	f001 f8a0 	bl	80012e0 <vTaskDelay>
 80001a0:	e7ee      	b.n	8000180 <task1+0x4>
 80001a2:	bf00      	nop
 80001a4:	40010800 	.word	0x40010800

080001a8 <task2>:
  }
}
void task2( void *pvParameters )
{
 80001a8:	b508      	push	{r3, lr}
  while (1)
  {
    /* Turn on led connected to PC.4 pin */
    GPIO_SetBits(GPIOA, GPIO_Pin_2);
 80001aa:	4c08      	ldr	r4, [pc, #32]	; (80001cc <task2+0x24>)
 80001ac:	2104      	movs	r1, #4
 80001ae:	4620      	mov	r0, r4
 80001b0:	f000 f975 	bl	800049e <GPIO_SetBits>
    /* Insert delay */
    vTaskDelay(pdMS_TO_TICKS(200));
 80001b4:	20c8      	movs	r0, #200	; 0xc8
 80001b6:	f001 f893 	bl	80012e0 <vTaskDelay>

    /* Turn off led connected to PC.4 pin */
    GPIO_ResetBits(GPIOA, GPIO_Pin_2);
 80001ba:	4620      	mov	r0, r4
 80001bc:	2104      	movs	r1, #4
 80001be:	f000 f970 	bl	80004a2 <GPIO_ResetBits>
    /* Insert delay */
    vTaskDelay(pdMS_TO_TICKS(200));
 80001c2:	20c8      	movs	r0, #200	; 0xc8
 80001c4:	f001 f88c 	bl	80012e0 <vTaskDelay>
 80001c8:	e7f0      	b.n	80001ac <task2+0x4>
 80001ca:	bf00      	nop
 80001cc:	40010800 	.word	0x40010800

080001d0 <vApplicationStackOverflowHook>:
  }
}


void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName )
{
 80001d0:	e7fe      	b.n	80001d0 <vApplicationStackOverflowHook>

080001d2 <NVIC_Configuration>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_Configuration(void)
{
 80001d2:	b508      	push	{r3, lr}
#ifdef  VECT_TAB_RAM  
  /* Set the Vector Table base location at 0x20000000 */ 
  NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); 
#else  /* VECT_TAB_FLASH  */
  /* Set the Vector Table base location at 0x08000000 */ 
  NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
 80001d4:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
 80001d8:	2100      	movs	r1, #0
 80001da:	f000 f86b 	bl	80002b4 <NVIC_SetVectorTable>
#endif


  NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );
}
 80001de:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );
 80001e2:	f44f 7040 	mov.w	r0, #768	; 0x300
 80001e6:	f000 b82d 	b.w	8000244 <NVIC_PriorityGroupConfig>

080001ea <prvSetupHardware>:
{
 80001ea:	b508      	push	{r3, lr}
  NVIC_Configuration();
 80001ec:	f7ff fff1 	bl	80001d2 <NVIC_Configuration>
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
 80001f0:	2101      	movs	r1, #1
 80001f2:	2004      	movs	r0, #4
 80001f4:	f000 fae0 	bl	80007b8 <RCC_APB2PeriphClockCmd>
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
 80001f8:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80001fc:	4905      	ldr	r1, [pc, #20]	; (8000214 <prvSetupHardware+0x2a>)
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 80001fe:	4806      	ldr	r0, [pc, #24]	; (8000218 <prvSetupHardware+0x2e>)
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
 8000200:	800b      	strh	r3, [r1, #0]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
 8000202:	2301      	movs	r3, #1
 8000204:	708b      	strb	r3, [r1, #2]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8000206:	2310      	movs	r3, #16
 8000208:	70cb      	strb	r3, [r1, #3]
}
 800020a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 800020e:	f000 b8da 	b.w	80003c6 <GPIO_Init>
 8000212:	bf00      	nop
 8000214:	20004966 	.word	0x20004966
 8000218:	40010800 	.word	0x40010800

0800021c <Delay>:
* Input          : nCount: specifies the delay time length.
* Output         : None
* Return         : None
*******************************************************************************/
void Delay(vu32 nCount)
{
 800021c:	b082      	sub	sp, #8
 800021e:	9001      	str	r0, [sp, #4]
  for(; nCount != 0; nCount--);
 8000220:	9b01      	ldr	r3, [sp, #4]
 8000222:	b90b      	cbnz	r3, 8000228 <Delay+0xc>
}
 8000224:	b002      	add	sp, #8
 8000226:	4770      	bx	lr
  for(; nCount != 0; nCount--);
 8000228:	9b01      	ldr	r3, [sp, #4]
 800022a:	3b01      	subs	r3, #1
 800022c:	9301      	str	r3, [sp, #4]
 800022e:	e7f7      	b.n	8000220 <Delay+0x4>

08000230 <NMI_Handler>:
 8000230:	4770      	bx	lr

08000232 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 8000232:	e7fe      	b.n	8000232 <HardFault_Handler>

08000234 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 8000234:	e7fe      	b.n	8000234 <MemManage_Handler>

08000236 <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 8000236:	e7fe      	b.n	8000236 <BusFault_Handler>

08000238 <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 8000238:	e7fe      	b.n	8000238 <UsageFault_Handler>

0800023a <SVC_Handler>:
 800023a:	4770      	bx	lr

0800023c <DebugMon_Handler>:
 800023c:	4770      	bx	lr

0800023e <PendSV_Handler>:
 800023e:	4770      	bx	lr

08000240 <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
 8000240:	4770      	bx	lr
	...

08000244 <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8000244:	f040 60bf 	orr.w	r0, r0, #100139008	; 0x5f80000
 8000248:	4b02      	ldr	r3, [pc, #8]	; (8000254 <NVIC_PriorityGroupConfig+0x10>)
 800024a:	f440 3000 	orr.w	r0, r0, #131072	; 0x20000
 800024e:	60d8      	str	r0, [r3, #12]
 8000250:	4770      	bx	lr
 8000252:	bf00      	nop
 8000254:	e000ed00 	.word	0xe000ed00

08000258 <NVIC_Init>:
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 8000258:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 800025a:	78c2      	ldrb	r2, [r0, #3]
 800025c:	7803      	ldrb	r3, [r0, #0]
 800025e:	b1e2      	cbz	r2, 800029a <NVIC_Init+0x42>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8000260:	4a12      	ldr	r2, [pc, #72]	; (80002ac <NVIC_Init+0x54>)
 8000262:	68d1      	ldr	r1, [r2, #12]
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8000264:	7842      	ldrb	r2, [r0, #1]
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8000266:	43c9      	mvns	r1, r1
 8000268:	f3c1 2102 	ubfx	r1, r1, #8, #3
    tmppre = (0x4 - tmppriority);
 800026c:	f1c1 0404 	rsb	r4, r1, #4
    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8000270:	40a2      	lsls	r2, r4
    tmpsub = tmpsub >> tmppriority;
 8000272:	240f      	movs	r4, #15
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 8000274:	7880      	ldrb	r0, [r0, #2]
    tmpsub = tmpsub >> tmppriority;
 8000276:	fa24 f101 	lsr.w	r1, r4, r1
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 800027a:	4001      	ands	r1, r0
 800027c:	430a      	orrs	r2, r1
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 800027e:	490c      	ldr	r1, [pc, #48]	; (80002b0 <NVIC_Init+0x58>)
    tmppriority = tmppriority << 0x04;
 8000280:	0112      	lsls	r2, r2, #4
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8000282:	18c8      	adds	r0, r1, r3
 8000284:	b2d2      	uxtb	r2, r2
 8000286:	f880 2300 	strb.w	r2, [r0, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 800028a:	f003 001f 	and.w	r0, r3, #31
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 800028e:	095a      	lsrs	r2, r3, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8000290:	2301      	movs	r3, #1
 8000292:	4083      	lsls	r3, r0
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8000294:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
 8000298:	bd10      	pop	{r4, pc}
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 800029a:	2101      	movs	r1, #1
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 800029c:	095a      	lsrs	r2, r3, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 800029e:	f003 031f 	and.w	r3, r3, #31
 80002a2:	fa01 f303 	lsl.w	r3, r1, r3
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80002a6:	3220      	adds	r2, #32
 80002a8:	4901      	ldr	r1, [pc, #4]	; (80002b0 <NVIC_Init+0x58>)
 80002aa:	e7f3      	b.n	8000294 <NVIC_Init+0x3c>
 80002ac:	e000ed00 	.word	0xe000ed00
 80002b0:	e000e100 	.word	0xe000e100

080002b4 <NVIC_SetVectorTable>:
{ 
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 80002b4:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
 80002b8:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
 80002bc:	4b01      	ldr	r3, [pc, #4]	; (80002c4 <NVIC_SetVectorTable+0x10>)
 80002be:	4301      	orrs	r1, r0
 80002c0:	6099      	str	r1, [r3, #8]
 80002c2:	4770      	bx	lr
 80002c4:	e000ed00 	.word	0xe000ed00

080002c8 <NVIC_SystemLPConfig>:
  *     @arg NVIC_LP_SLEEPONEXIT
  * @param  NewState: new state of LP condition. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState)
{
 80002c8:	4b04      	ldr	r3, [pc, #16]	; (80002dc <NVIC_SystemLPConfig+0x14>)
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
  {
    SCB->SCR |= LowPowerMode;
 80002ca:	691a      	ldr	r2, [r3, #16]
  if (NewState != DISABLE)
 80002cc:	b111      	cbz	r1, 80002d4 <NVIC_SystemLPConfig+0xc>
    SCB->SCR |= LowPowerMode;
 80002ce:	4310      	orrs	r0, r2
  }
  else
  {
    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);
 80002d0:	6118      	str	r0, [r3, #16]
 80002d2:	4770      	bx	lr
 80002d4:	ea22 0000 	bic.w	r0, r2, r0
 80002d8:	e7fa      	b.n	80002d0 <NVIC_SystemLPConfig+0x8>
 80002da:	bf00      	nop
 80002dc:	e000ed00 	.word	0xe000ed00

080002e0 <SysTick_CLKSourceConfig>:
  *     @arg SysTick_CLKSource_HCLK_Div8: AHB clock divided by 8 selected as SysTick clock source.
  *     @arg SysTick_CLKSource_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
 80002e0:	4b04      	ldr	r3, [pc, #16]	; (80002f4 <SysTick_CLKSourceConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 80002e2:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 80002e4:	681a      	ldr	r2, [r3, #0]
 80002e6:	bf0c      	ite	eq
 80002e8:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 80002ec:	f022 0204 	bicne.w	r2, r2, #4
 80002f0:	601a      	str	r2, [r3, #0]
 80002f2:	4770      	bx	lr
 80002f4:	e000e010 	.word	0xe000e010

080002f8 <GPIO_DeInit>:
  * @brief  Deinitializes the GPIOx peripheral registers to their default reset values.
  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
  * @retval None
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 80002f8:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  if (GPIOx == GPIOA)
 80002fa:	4b26      	ldr	r3, [pc, #152]	; (8000394 <GPIO_DeInit+0x9c>)
 80002fc:	4298      	cmp	r0, r3
 80002fe:	d109      	bne.n	8000314 <GPIO_DeInit+0x1c>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
 8000300:	2101      	movs	r1, #1
 8000302:	2004      	movs	r0, #4
 8000304:	f000 fa70 	bl	80007e8 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
 8000308:	2100      	movs	r1, #0
 800030a:	2004      	movs	r0, #4
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    }
  }
}
 800030c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
 8000310:	f000 ba6a 	b.w	80007e8 <RCC_APB2PeriphResetCmd>
  else if (GPIOx == GPIOB)
 8000314:	4b20      	ldr	r3, [pc, #128]	; (8000398 <GPIO_DeInit+0xa0>)
 8000316:	4298      	cmp	r0, r3
 8000318:	d106      	bne.n	8000328 <GPIO_DeInit+0x30>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
 800031a:	2101      	movs	r1, #1
 800031c:	2008      	movs	r0, #8
 800031e:	f000 fa63 	bl	80007e8 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
 8000322:	2100      	movs	r1, #0
 8000324:	2008      	movs	r0, #8
 8000326:	e7f1      	b.n	800030c <GPIO_DeInit+0x14>
  else if (GPIOx == GPIOC)
 8000328:	4b1c      	ldr	r3, [pc, #112]	; (800039c <GPIO_DeInit+0xa4>)
 800032a:	4298      	cmp	r0, r3
 800032c:	d106      	bne.n	800033c <GPIO_DeInit+0x44>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
 800032e:	2101      	movs	r1, #1
 8000330:	2010      	movs	r0, #16
 8000332:	f000 fa59 	bl	80007e8 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
 8000336:	2100      	movs	r1, #0
 8000338:	2010      	movs	r0, #16
 800033a:	e7e7      	b.n	800030c <GPIO_DeInit+0x14>
  else if (GPIOx == GPIOD)
 800033c:	4b18      	ldr	r3, [pc, #96]	; (80003a0 <GPIO_DeInit+0xa8>)
 800033e:	4298      	cmp	r0, r3
 8000340:	d106      	bne.n	8000350 <GPIO_DeInit+0x58>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
 8000342:	2101      	movs	r1, #1
 8000344:	2020      	movs	r0, #32
 8000346:	f000 fa4f 	bl	80007e8 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
 800034a:	2100      	movs	r1, #0
 800034c:	2020      	movs	r0, #32
 800034e:	e7dd      	b.n	800030c <GPIO_DeInit+0x14>
  else if (GPIOx == GPIOE)
 8000350:	4b14      	ldr	r3, [pc, #80]	; (80003a4 <GPIO_DeInit+0xac>)
 8000352:	4298      	cmp	r0, r3
 8000354:	d106      	bne.n	8000364 <GPIO_DeInit+0x6c>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
 8000356:	2101      	movs	r1, #1
 8000358:	2040      	movs	r0, #64	; 0x40
 800035a:	f000 fa45 	bl	80007e8 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
 800035e:	2100      	movs	r1, #0
 8000360:	2040      	movs	r0, #64	; 0x40
 8000362:	e7d3      	b.n	800030c <GPIO_DeInit+0x14>
  else if (GPIOx == GPIOF)
 8000364:	4b10      	ldr	r3, [pc, #64]	; (80003a8 <GPIO_DeInit+0xb0>)
 8000366:	4298      	cmp	r0, r3
 8000368:	d106      	bne.n	8000378 <GPIO_DeInit+0x80>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
 800036a:	2101      	movs	r1, #1
 800036c:	2080      	movs	r0, #128	; 0x80
 800036e:	f000 fa3b 	bl	80007e8 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
 8000372:	2100      	movs	r1, #0
 8000374:	2080      	movs	r0, #128	; 0x80
 8000376:	e7c9      	b.n	800030c <GPIO_DeInit+0x14>
    if (GPIOx == GPIOG)
 8000378:	4b0c      	ldr	r3, [pc, #48]	; (80003ac <GPIO_DeInit+0xb4>)
 800037a:	4298      	cmp	r0, r3
 800037c:	d108      	bne.n	8000390 <GPIO_DeInit+0x98>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
 800037e:	2101      	movs	r1, #1
 8000380:	f44f 7080 	mov.w	r0, #256	; 0x100
 8000384:	f000 fa30 	bl	80007e8 <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
 8000388:	2100      	movs	r1, #0
 800038a:	f44f 7080 	mov.w	r0, #256	; 0x100
 800038e:	e7bd      	b.n	800030c <GPIO_DeInit+0x14>
 8000390:	bd08      	pop	{r3, pc}
 8000392:	bf00      	nop
 8000394:	40010800 	.word	0x40010800
 8000398:	40010c00 	.word	0x40010c00
 800039c:	40011000 	.word	0x40011000
 80003a0:	40011400 	.word	0x40011400
 80003a4:	40011800 	.word	0x40011800
 80003a8:	40011c00 	.word	0x40011c00
 80003ac:	40012000 	.word	0x40012000

080003b0 <GPIO_AFIODeInit>:
  * @param  None
  * @retval None
  */
void GPIO_AFIODeInit(void)
{
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
 80003b0:	2101      	movs	r1, #1
{
 80003b2:	b508      	push	{r3, lr}
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
 80003b4:	4608      	mov	r0, r1
 80003b6:	f000 fa17 	bl	80007e8 <RCC_APB2PeriphResetCmd>
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
}
 80003ba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
 80003be:	2100      	movs	r1, #0
 80003c0:	2001      	movs	r0, #1
 80003c2:	f000 ba11 	b.w	80007e8 <RCC_APB2PeriphResetCmd>

080003c6 <GPIO_Init>:
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
 80003c6:	78cb      	ldrb	r3, [r1, #3]
{
 80003c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
 80003cc:	06da      	lsls	r2, r3, #27
 80003ce:	bf48      	it	mi
 80003d0:	788a      	ldrbmi	r2, [r1, #2]
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 80003d2:	880e      	ldrh	r6, [r1, #0]
 80003d4:	f003 050f 	and.w	r5, r3, #15
 80003d8:	bf48      	it	mi
 80003da:	4315      	orrmi	r5, r2
 80003dc:	f016 0fff 	tst.w	r6, #255	; 0xff
 80003e0:	d01a      	beq.n	8000418 <GPIO_Init+0x52>
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 80003e2:	2100      	movs	r1, #0
    {
      pos = ((uint32_t)0x01) << pinpos;
 80003e4:	f04f 0e01 	mov.w	lr, #1
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 80003e8:	f04f 0c0f 	mov.w	ip, #15
    tmpreg = GPIOx->CRL;
 80003ec:	6802      	ldr	r2, [r0, #0]
      pos = ((uint32_t)0x01) << pinpos;
 80003ee:	fa0e f701 	lsl.w	r7, lr, r1
      if (currentpin == pos)
 80003f2:	ea37 0406 	bics.w	r4, r7, r6
 80003f6:	d10b      	bne.n	8000410 <GPIO_Init+0x4a>
        pos = pinpos << 2;
 80003f8:	008c      	lsls	r4, r1, #2
        pinmask = ((uint32_t)0x0F) << pos;
 80003fa:	fa0c f804 	lsl.w	r8, ip, r4
        tmpreg &= ~pinmask;
 80003fe:	ea22 0208 	bic.w	r2, r2, r8
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8000402:	fa05 f404 	lsl.w	r4, r5, r4
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8000406:	2b28      	cmp	r3, #40	; 0x28
        tmpreg |= (currentmode << pos);
 8000408:	ea42 0204 	orr.w	r2, r2, r4
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 800040c:	d125      	bne.n	800045a <GPIO_Init+0x94>
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
 800040e:	6147      	str	r7, [r0, #20]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8000410:	3101      	adds	r1, #1
 8000412:	2908      	cmp	r1, #8
 8000414:	d1eb      	bne.n	80003ee <GPIO_Init+0x28>
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
          }
        }
      }
    }
    GPIOx->CRL = tmpreg;
 8000416:	6002      	str	r2, [r0, #0]
  }
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
 8000418:	2eff      	cmp	r6, #255	; 0xff
 800041a:	d91c      	bls.n	8000456 <GPIO_Init+0x90>
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 800041c:	2100      	movs	r1, #0
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
 800041e:	f04f 0e01 	mov.w	lr, #1
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8000422:	f04f 0c0f 	mov.w	ip, #15
    tmpreg = GPIOx->CRH;
 8000426:	6842      	ldr	r2, [r0, #4]
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
 8000428:	f101 0408 	add.w	r4, r1, #8
 800042c:	fa0e f404 	lsl.w	r4, lr, r4
      if (currentpin == pos)
 8000430:	ea34 0706 	bics.w	r7, r4, r6
 8000434:	d10b      	bne.n	800044e <GPIO_Init+0x88>
        pos = pinpos << 2;
 8000436:	008f      	lsls	r7, r1, #2
        pinmask = ((uint32_t)0x0F) << pos;
 8000438:	fa0c f807 	lsl.w	r8, ip, r7
        tmpreg &= ~pinmask;
 800043c:	ea22 0208 	bic.w	r2, r2, r8
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8000440:	fa05 f707 	lsl.w	r7, r5, r7
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8000444:	2b28      	cmp	r3, #40	; 0x28
        tmpreg |= (currentmode << pos);
 8000446:	ea42 0207 	orr.w	r2, r2, r7
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 800044a:	d10a      	bne.n	8000462 <GPIO_Init+0x9c>
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
 800044c:	6144      	str	r4, [r0, #20]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 800044e:	3101      	adds	r1, #1
 8000450:	2908      	cmp	r1, #8
 8000452:	d1e9      	bne.n	8000428 <GPIO_Init+0x62>
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
      }
    }
    GPIOx->CRH = tmpreg;
 8000454:	6042      	str	r2, [r0, #4]
 8000456:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 800045a:	2b48      	cmp	r3, #72	; 0x48
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
 800045c:	bf08      	it	eq
 800045e:	6107      	streq	r7, [r0, #16]
 8000460:	e7d6      	b.n	8000410 <GPIO_Init+0x4a>
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 8000462:	2b48      	cmp	r3, #72	; 0x48
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8000464:	bf08      	it	eq
 8000466:	6104      	streq	r4, [r0, #16]
 8000468:	e7f1      	b.n	800044e <GPIO_Init+0x88>

0800046a <GPIO_StructInit>:
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 800046a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800046e:	8003      	strh	r3, [r0, #0]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 8000470:	2302      	movs	r3, #2
 8000472:	7083      	strb	r3, [r0, #2]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
 8000474:	2304      	movs	r3, #4
 8000476:	70c3      	strb	r3, [r0, #3]
 8000478:	4770      	bx	lr

0800047a <GPIO_ReadInputDataBit>:
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
  
  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 800047a:	6883      	ldr	r3, [r0, #8]
 800047c:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 800047e:	bf14      	ite	ne
 8000480:	2001      	movne	r0, #1
 8000482:	2000      	moveq	r0, #0
 8000484:	4770      	bx	lr

08000486 <GPIO_ReadInputData>:
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  return ((uint16_t)GPIOx->IDR);
 8000486:	6880      	ldr	r0, [r0, #8]
}
 8000488:	b280      	uxth	r0, r0
 800048a:	4770      	bx	lr

0800048c <GPIO_ReadOutputDataBit>:
  uint8_t bitstatus = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
  
  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
 800048c:	68c3      	ldr	r3, [r0, #12]
 800048e:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 8000490:	bf14      	ite	ne
 8000492:	2001      	movne	r0, #1
 8000494:	2000      	moveq	r0, #0
 8000496:	4770      	bx	lr

08000498 <GPIO_ReadOutputData>:
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    
  return ((uint16_t)GPIOx->ODR);
 8000498:	68c0      	ldr	r0, [r0, #12]
}
 800049a:	b280      	uxth	r0, r0
 800049c:	4770      	bx	lr

0800049e <GPIO_SetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BSRR = GPIO_Pin;
 800049e:	6101      	str	r1, [r0, #16]
 80004a0:	4770      	bx	lr

080004a2 <GPIO_ResetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BRR = GPIO_Pin;
 80004a2:	6141      	str	r1, [r0, #20]
 80004a4:	4770      	bx	lr

080004a6 <GPIO_WriteBit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
  
  if (BitVal != Bit_RESET)
 80004a6:	b10a      	cbz	r2, 80004ac <GPIO_WriteBit+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
 80004a8:	6101      	str	r1, [r0, #16]
 80004aa:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = GPIO_Pin;
 80004ac:	6141      	str	r1, [r0, #20]
 80004ae:	4770      	bx	lr

080004b0 <GPIO_Write>:
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  GPIOx->ODR = PortVal;
 80004b0:	60c1      	str	r1, [r0, #12]
 80004b2:	4770      	bx	lr

080004b4 <GPIO_PinLockConfig>:
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  tmp |= GPIO_Pin;
 80004b4:	f441 3380 	orr.w	r3, r1, #65536	; 0x10000
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 80004b8:	6183      	str	r3, [r0, #24]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
 80004ba:	6181      	str	r1, [r0, #24]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 80004bc:	6183      	str	r3, [r0, #24]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 80004be:	6983      	ldr	r3, [r0, #24]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 80004c0:	6983      	ldr	r3, [r0, #24]
 80004c2:	4770      	bx	lr

080004c4 <GPIO_EventOutputConfig>:
  uint32_t tmpreg = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    
  tmpreg = AFIO->EVCR;
 80004c4:	4a05      	ldr	r2, [pc, #20]	; (80004dc <GPIO_EventOutputConfig+0x18>)
 80004c6:	6813      	ldr	r3, [r2, #0]
  /* Clear the PORT[6:4] and PIN[3:0] bits */
  tmpreg &= EVCR_PORTPINCONFIG_MASK;
 80004c8:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80004cc:	041b      	lsls	r3, r3, #16
 80004ce:	0c1b      	lsrs	r3, r3, #16
 80004d0:	4319      	orrs	r1, r3
  tmpreg |= (uint32_t)GPIO_PortSource << 0x04;
  tmpreg |= GPIO_PinSource;
 80004d2:	ea41 1100 	orr.w	r1, r1, r0, lsl #4
  AFIO->EVCR = tmpreg;
 80004d6:	6011      	str	r1, [r2, #0]
 80004d8:	4770      	bx	lr
 80004da:	bf00      	nop
 80004dc:	40010000 	.word	0x40010000

080004e0 <GPIO_EventOutputCmd>:
void GPIO_EventOutputCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) EVCR_EVOE_BB = (uint32_t)NewState;
 80004e0:	4b01      	ldr	r3, [pc, #4]	; (80004e8 <GPIO_EventOutputCmd+0x8>)
 80004e2:	6018      	str	r0, [r3, #0]
 80004e4:	4770      	bx	lr
 80004e6:	bf00      	nop
 80004e8:	4220001c 	.word	0x4220001c

080004ec <GPIO_PinRemapConfig>:

  /* Check the parameters */
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if((GPIO_Remap & 0x80000000) == 0x80000000)
 80004ec:	2800      	cmp	r0, #0
 80004ee:	4a16      	ldr	r2, [pc, #88]	; (8000548 <GPIO_PinRemapConfig+0x5c>)
{
 80004f0:	b530      	push	{r4, r5, lr}
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 80004f2:	f400 1540 	and.w	r5, r0, #3145728	; 0x300000
    tmpreg = AFIO->MAPR2;
 80004f6:	bfb4      	ite	lt
 80004f8:	69d3      	ldrlt	r3, [r2, #28]
    tmpreg = AFIO->MAPR;
 80004fa:	6853      	ldrge	r3, [r2, #4]
  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 80004fc:	f5b5 1f40 	cmp.w	r5, #3145728	; 0x300000
  tmp = GPIO_Remap & LSB_MASK;
 8000500:	b284      	uxth	r4, r0
  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 8000502:	d110      	bne.n	8000526 <GPIO_PinRemapConfig+0x3a>
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
 8000504:	6855      	ldr	r5, [r2, #4]
    tmpreg &= DBGAFR_SWJCFG_MASK;
 8000506:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
 800050a:	f025 6570 	bic.w	r5, r5, #251658240	; 0xf000000
 800050e:	6055      	str	r5, [r2, #4]
  {
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
  }

  if (NewState != DISABLE)
 8000510:	b119      	cbz	r1, 800051a <GPIO_PinRemapConfig+0x2e>
  {
    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
 8000512:	0d42      	lsrs	r2, r0, #21
 8000514:	0112      	lsls	r2, r2, #4
 8000516:	4094      	lsls	r4, r2
 8000518:	4323      	orrs	r3, r4
 800051a:	4a0b      	ldr	r2, [pc, #44]	; (8000548 <GPIO_PinRemapConfig+0x5c>)
  }

  if((GPIO_Remap & 0x80000000) == 0x80000000)
 800051c:	2800      	cmp	r0, #0
  {
    AFIO->MAPR2 = tmpreg;
 800051e:	bfb4      	ite	lt
 8000520:	61d3      	strlt	r3, [r2, #28]
  }
  else
  {
    AFIO->MAPR = tmpreg;
 8000522:	6053      	strge	r3, [r2, #4]
 8000524:	bd30      	pop	{r4, r5, pc}
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
 8000526:	02c2      	lsls	r2, r0, #11
    tmp1 = ((uint32_t)0x03) << tmpmask;
 8000528:	bf4d      	iteet	mi
 800052a:	2203      	movmi	r2, #3
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
 800052c:	0d42      	lsrpl	r2, r0, #21
 800052e:	0112      	lslpl	r2, r2, #4
  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
 8000530:	f3c0 4503 	ubfxmi	r5, r0, #16, #4
    tmp1 = ((uint32_t)0x03) << tmpmask;
 8000534:	bf4c      	ite	mi
 8000536:	40aa      	lslmi	r2, r5
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
 8000538:	fa04 f202 	lslpl.w	r2, r4, r2
 800053c:	ea23 0302 	bic.w	r3, r3, r2
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
 8000540:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
 8000544:	e7e4      	b.n	8000510 <GPIO_PinRemapConfig+0x24>
 8000546:	bf00      	nop
 8000548:	40010000 	.word	0x40010000

0800054c <GPIO_EXTILineConfig>:
  * @param  GPIO_PinSource: specifies the EXTI line to be configured.
  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
  * @retval None
  */
void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
{
 800054c:	b510      	push	{r4, lr}
  uint32_t tmp = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));
 800054e:	240f      	movs	r4, #15
 8000550:	f001 0303 	and.w	r3, r1, #3
 8000554:	f001 01fc 	and.w	r1, r1, #252	; 0xfc
 8000558:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 800055c:	f501 3180 	add.w	r1, r1, #65536	; 0x10000
  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
 8000560:	688a      	ldr	r2, [r1, #8]
  tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));
 8000562:	009b      	lsls	r3, r3, #2
 8000564:	409c      	lsls	r4, r3
  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
 8000566:	ea22 0204 	bic.w	r2, r2, r4
 800056a:	608a      	str	r2, [r1, #8]
  AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((uint32_t)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (uint8_t)0x03)));
 800056c:	688a      	ldr	r2, [r1, #8]
 800056e:	4098      	lsls	r0, r3
 8000570:	4310      	orrs	r0, r2
 8000572:	6088      	str	r0, [r1, #8]
 8000574:	bd10      	pop	{r4, pc}

08000576 <GPIO_ETH_MediaInterfaceConfig>:
void GPIO_ETH_MediaInterfaceConfig(uint32_t GPIO_ETH_MediaInterface) 
{ 
  assert_param(IS_GPIO_ETH_MEDIA_INTERFACE(GPIO_ETH_MediaInterface)); 

  /* Configure MII_RMII selection bit */ 
  *(__IO uint32_t *) MAPR_MII_RMII_SEL_BB = GPIO_ETH_MediaInterface; 
 8000576:	4b01      	ldr	r3, [pc, #4]	; (800057c <GPIO_ETH_MediaInterfaceConfig+0x6>)
 8000578:	6018      	str	r0, [r3, #0]
 800057a:	4770      	bx	lr
 800057c:	422000dc 	.word	0x422000dc

08000580 <RCC_DeInit>:
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000580:	4b0d      	ldr	r3, [pc, #52]	; (80005b8 <RCC_DeInit+0x38>)
 8000582:	681a      	ldr	r2, [r3, #0]
 8000584:	f042 0201 	orr.w	r2, r2, #1
 8000588:	601a      	str	r2, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 800058a:	6859      	ldr	r1, [r3, #4]
 800058c:	4a0b      	ldr	r2, [pc, #44]	; (80005bc <RCC_DeInit+0x3c>)
 800058e:	400a      	ands	r2, r1
 8000590:	605a      	str	r2, [r3, #4]
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000592:	681a      	ldr	r2, [r3, #0]
 8000594:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8000598:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800059c:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 800059e:	681a      	ldr	r2, [r3, #0]
 80005a0:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80005a4:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 80005a6:	685a      	ldr	r2, [r3, #4]
 80005a8:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 80005ac:	605a      	str	r2, [r3, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 80005ae:	f44f 021f 	mov.w	r2, #10420224	; 0x9f0000
 80005b2:	609a      	str	r2, [r3, #8]
 80005b4:	4770      	bx	lr
 80005b6:	bf00      	nop
 80005b8:	40021000 	.word	0x40021000
 80005bc:	f8ff0000 	.word	0xf8ff0000

080005c0 <RCC_HSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));
  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 80005c0:	4b0c      	ldr	r3, [pc, #48]	; (80005f4 <RCC_HSEConfig+0x34>)
  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 80005c2:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
  RCC->CR &= CR_HSEON_Reset;
 80005c6:	681a      	ldr	r2, [r3, #0]
 80005c8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80005cc:	601a      	str	r2, [r3, #0]
  RCC->CR &= CR_HSEBYP_Reset;
 80005ce:	681a      	ldr	r2, [r3, #0]
 80005d0:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80005d4:	601a      	str	r2, [r3, #0]
  switch(RCC_HSE)
 80005d6:	d003      	beq.n	80005e0 <RCC_HSEConfig+0x20>
 80005d8:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
 80005dc:	d005      	beq.n	80005ea <RCC_HSEConfig+0x2a>
 80005de:	4770      	bx	lr
  {
    case RCC_HSE_ON:
      /* Set HSEON bit */
      RCC->CR |= CR_HSEON_Set;
 80005e0:	681a      	ldr	r2, [r3, #0]
 80005e2:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
      break;
      
    case RCC_HSE_Bypass:
      /* Set HSEBYP and HSEON bits */
      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
 80005e6:	601a      	str	r2, [r3, #0]
 80005e8:	4770      	bx	lr
 80005ea:	681a      	ldr	r2, [r3, #0]
 80005ec:	f442 22a0 	orr.w	r2, r2, #327680	; 0x50000
 80005f0:	e7f9      	b.n	80005e6 <RCC_HSEConfig+0x26>
 80005f2:	bf00      	nop
 80005f4:	40021000 	.word	0x40021000

080005f8 <RCC_AdjustHSICalibrationValue>:
void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
  tmpreg = RCC->CR;
 80005f8:	4a03      	ldr	r2, [pc, #12]	; (8000608 <RCC_AdjustHSICalibrationValue+0x10>)
 80005fa:	6813      	ldr	r3, [r2, #0]
  /* Clear HSITRIM[4:0] bits */
  tmpreg &= CR_HSITRIM_Mask;
 80005fc:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
 8000600:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3
  /* Store the new value */
  RCC->CR = tmpreg;
 8000604:	6010      	str	r0, [r2, #0]
 8000606:	4770      	bx	lr
 8000608:	40021000 	.word	0x40021000

0800060c <RCC_HSICmd>:
  */
void RCC_HSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 800060c:	4b01      	ldr	r3, [pc, #4]	; (8000614 <RCC_HSICmd+0x8>)
 800060e:	6018      	str	r0, [r3, #0]
 8000610:	4770      	bx	lr
 8000612:	bf00      	nop
 8000614:	42420000 	.word	0x42420000

08000618 <RCC_PLLConfig>:

  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));

  tmpreg = RCC->CFGR;
 8000618:	4a03      	ldr	r2, [pc, #12]	; (8000628 <RCC_PLLConfig+0x10>)
 800061a:	6853      	ldr	r3, [r2, #4]
  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  tmpreg &= CFGR_PLL_Mask;
 800061c:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 8000620:	4319      	orrs	r1, r3
  /* Set the PLL configuration bits */
  tmpreg |= RCC_PLLSource | RCC_PLLMul;
 8000622:	4301      	orrs	r1, r0
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8000624:	6051      	str	r1, [r2, #4]
 8000626:	4770      	bx	lr
 8000628:	40021000 	.word	0x40021000

0800062c <RCC_PLLCmd>:
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 800062c:	4b01      	ldr	r3, [pc, #4]	; (8000634 <RCC_PLLCmd+0x8>)
 800062e:	6018      	str	r0, [r3, #0]
 8000630:	4770      	bx	lr
 8000632:	bf00      	nop
 8000634:	42420060 	.word	0x42420060

08000638 <RCC_SYSCLKConfig>:
void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
  tmpreg = RCC->CFGR;
 8000638:	4a03      	ldr	r2, [pc, #12]	; (8000648 <RCC_SYSCLKConfig+0x10>)
 800063a:	6853      	ldr	r3, [r2, #4]
  /* Clear SW[1:0] bits */
  tmpreg &= CFGR_SW_Mask;
 800063c:	f023 0303 	bic.w	r3, r3, #3
  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 8000640:	4318      	orrs	r0, r3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8000642:	6050      	str	r0, [r2, #4]
 8000644:	4770      	bx	lr
 8000646:	bf00      	nop
 8000648:	40021000 	.word	0x40021000

0800064c <RCC_GetSYSCLKSource>:
  *     - 0x04: HSE used as system clock
  *     - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
  return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
 800064c:	4b02      	ldr	r3, [pc, #8]	; (8000658 <RCC_GetSYSCLKSource+0xc>)
 800064e:	6858      	ldr	r0, [r3, #4]
}
 8000650:	f000 000c 	and.w	r0, r0, #12
 8000654:	4770      	bx	lr
 8000656:	bf00      	nop
 8000658:	40021000 	.word	0x40021000

0800065c <RCC_HCLKConfig>:
void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
  tmpreg = RCC->CFGR;
 800065c:	4a03      	ldr	r2, [pc, #12]	; (800066c <RCC_HCLKConfig+0x10>)
 800065e:	6853      	ldr	r3, [r2, #4]
  /* Clear HPRE[3:0] bits */
  tmpreg &= CFGR_HPRE_Reset_Mask;
 8000660:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 8000664:	4318      	orrs	r0, r3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8000666:	6050      	str	r0, [r2, #4]
 8000668:	4770      	bx	lr
 800066a:	bf00      	nop
 800066c:	40021000 	.word	0x40021000

08000670 <RCC_PCLK1Config>:
void RCC_PCLK1Config(uint32_t RCC_HCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 8000670:	4a03      	ldr	r2, [pc, #12]	; (8000680 <RCC_PCLK1Config+0x10>)
 8000672:	6853      	ldr	r3, [r2, #4]
  /* Clear PPRE1[2:0] bits */
  tmpreg &= CFGR_PPRE1_Reset_Mask;
 8000674:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 8000678:	4318      	orrs	r0, r3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 800067a:	6050      	str	r0, [r2, #4]
 800067c:	4770      	bx	lr
 800067e:	bf00      	nop
 8000680:	40021000 	.word	0x40021000

08000684 <RCC_PCLK2Config>:
void RCC_PCLK2Config(uint32_t RCC_HCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 8000684:	4a03      	ldr	r2, [pc, #12]	; (8000694 <RCC_PCLK2Config+0x10>)
 8000686:	6853      	ldr	r3, [r2, #4]
  /* Clear PPRE2[2:0] bits */
  tmpreg &= CFGR_PPRE2_Reset_Mask;
 8000688:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 800068c:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8000690:	6050      	str	r0, [r2, #4]
 8000692:	4770      	bx	lr
 8000694:	40021000 	.word	0x40021000

08000698 <RCC_ITConfig>:
  * @param  NewState: new state of the specified RCC interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
 8000698:	4b04      	ldr	r3, [pc, #16]	; (80006ac <RCC_ITConfig+0x14>)
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 800069a:	781a      	ldrb	r2, [r3, #0]
  if (NewState != DISABLE)
 800069c:	b111      	cbz	r1, 80006a4 <RCC_ITConfig+0xc>
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 800069e:	4310      	orrs	r0, r2
  }
  else
  {
    /* Perform Byte access to RCC_CIR bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
 80006a0:	7018      	strb	r0, [r3, #0]
 80006a2:	4770      	bx	lr
 80006a4:	ea22 0000 	bic.w	r0, r2, r0
 80006a8:	e7fa      	b.n	80006a0 <RCC_ITConfig+0x8>
 80006aa:	bf00      	nop
 80006ac:	40021009 	.word	0x40021009

080006b0 <RCC_USBCLKConfig>:
void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));

  *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
 80006b0:	4b01      	ldr	r3, [pc, #4]	; (80006b8 <RCC_USBCLKConfig+0x8>)
 80006b2:	6018      	str	r0, [r3, #0]
 80006b4:	4770      	bx	lr
 80006b6:	bf00      	nop
 80006b8:	424200d8 	.word	0x424200d8

080006bc <RCC_ADCCLKConfig>:
void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
  tmpreg = RCC->CFGR;
 80006bc:	4a03      	ldr	r2, [pc, #12]	; (80006cc <RCC_ADCCLKConfig+0x10>)
 80006be:	6853      	ldr	r3, [r2, #4]
  /* Clear ADCPRE[1:0] bits */
  tmpreg &= CFGR_ADCPRE_Reset_Mask;
 80006c0:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
  /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
  tmpreg |= RCC_PCLK2;
 80006c4:	4318      	orrs	r0, r3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80006c6:	6050      	str	r0, [r2, #4]
 80006c8:	4770      	bx	lr
 80006ca:	bf00      	nop
 80006cc:	40021000 	.word	0x40021000

080006d0 <RCC_LSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));
  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 80006d0:	2200      	movs	r2, #0
 80006d2:	4b06      	ldr	r3, [pc, #24]	; (80006ec <RCC_LSEConfig+0x1c>)
  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
 80006d4:	2801      	cmp	r0, #1
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 80006d6:	701a      	strb	r2, [r3, #0]
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 80006d8:	701a      	strb	r2, [r3, #0]
  switch(RCC_LSE)
 80006da:	d002      	beq.n	80006e2 <RCC_LSEConfig+0x12>
 80006dc:	2804      	cmp	r0, #4
 80006de:	d002      	beq.n	80006e6 <RCC_LSEConfig+0x16>
 80006e0:	4770      	bx	lr
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
 80006e2:	7018      	strb	r0, [r3, #0]
      break;
 80006e4:	4770      	bx	lr
      
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
 80006e6:	2205      	movs	r2, #5
 80006e8:	701a      	strb	r2, [r3, #0]
 80006ea:	4770      	bx	lr
 80006ec:	40021020 	.word	0x40021020

080006f0 <RCC_LSICmd>:
  */
void RCC_LSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 80006f0:	4b01      	ldr	r3, [pc, #4]	; (80006f8 <RCC_LSICmd+0x8>)
 80006f2:	6018      	str	r0, [r3, #0]
 80006f4:	4770      	bx	lr
 80006f6:	bf00      	nop
 80006f8:	42420480 	.word	0x42420480

080006fc <RCC_RTCCLKConfig>:
void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
  /* Select the RTC clock source */
  RCC->BDCR |= RCC_RTCCLKSource;
 80006fc:	4a02      	ldr	r2, [pc, #8]	; (8000708 <RCC_RTCCLKConfig+0xc>)
 80006fe:	6a13      	ldr	r3, [r2, #32]
 8000700:	4318      	orrs	r0, r3
 8000702:	6210      	str	r0, [r2, #32]
 8000704:	4770      	bx	lr
 8000706:	bf00      	nop
 8000708:	40021000 	.word	0x40021000

0800070c <RCC_RTCCLKCmd>:
  */
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 800070c:	4b01      	ldr	r3, [pc, #4]	; (8000714 <RCC_RTCCLKCmd+0x8>)
 800070e:	6018      	str	r0, [r3, #0]
 8000710:	4770      	bx	lr
 8000712:	bf00      	nop
 8000714:	4242043c 	.word	0x4242043c

08000718 <RCC_GetClocksFreq>:
#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
  uint32_t prediv1factor = 0;
#endif
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 8000718:	4a1c      	ldr	r2, [pc, #112]	; (800078c <RCC_GetClocksFreq+0x74>)
{
 800071a:	b510      	push	{r4, lr}
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 800071c:	6853      	ldr	r3, [r2, #4]
 800071e:	f003 030c 	and.w	r3, r3, #12
  
  switch (tmp)
 8000722:	2b04      	cmp	r3, #4
 8000724:	d001      	beq.n	800072a <RCC_GetClocksFreq+0x12>
 8000726:	2b08      	cmp	r3, #8
 8000728:	d01f      	beq.n	800076a <RCC_GetClocksFreq+0x52>
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 800072a:	4b19      	ldr	r3, [pc, #100]	; (8000790 <RCC_GetClocksFreq+0x78>)
        {/* HSE oscillator clock divided by 2 */
          RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
        }
        else
        {
          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;
 800072c:	6003      	str	r3, [r0, #0]
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 800072e:	6853      	ldr	r3, [r2, #4]
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];
 8000730:	4c18      	ldr	r4, [pc, #96]	; (8000794 <RCC_GetClocksFreq+0x7c>)
  tmp = tmp >> 4;
 8000732:	f3c3 1303 	ubfx	r3, r3, #4, #4
  presc = APBAHBPrescTable[tmp];
 8000736:	5ce1      	ldrb	r1, [r4, r3]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8000738:	6803      	ldr	r3, [r0, #0]
 800073a:	40cb      	lsrs	r3, r1
 800073c:	6043      	str	r3, [r0, #4]
  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
 800073e:	6851      	ldr	r1, [r2, #4]
  tmp = tmp >> 8;
 8000740:	f3c1 2102 	ubfx	r1, r1, #8, #3
  presc = APBAHBPrescTable[tmp];
 8000744:	5c61      	ldrb	r1, [r4, r1]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8000746:	fa23 f101 	lsr.w	r1, r3, r1
 800074a:	6081      	str	r1, [r0, #8]
  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
 800074c:	6851      	ldr	r1, [r2, #4]
  tmp = tmp >> 11;
 800074e:	f3c1 21c2 	ubfx	r1, r1, #11, #3
  presc = APBAHBPrescTable[tmp];
 8000752:	5c61      	ldrb	r1, [r4, r1]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8000754:	40cb      	lsrs	r3, r1
 8000756:	60c3      	str	r3, [r0, #12]
  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
 8000758:	6852      	ldr	r2, [r2, #4]
  tmp = tmp >> 14;
  presc = ADCPrescTable[tmp];
 800075a:	490f      	ldr	r1, [pc, #60]	; (8000798 <RCC_GetClocksFreq+0x80>)
  tmp = tmp >> 14;
 800075c:	f3c2 3281 	ubfx	r2, r2, #14, #2
  presc = ADCPrescTable[tmp];
 8000760:	5c8a      	ldrb	r2, [r1, r2]
  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
 8000762:	fbb3 f3f2 	udiv	r3, r3, r2
 8000766:	6103      	str	r3, [r0, #16]
 8000768:	bd10      	pop	{r4, pc}
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
 800076a:	6853      	ldr	r3, [r2, #4]
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
 800076c:	6851      	ldr	r1, [r2, #4]
      pllmull = ( pllmull >> 18) + 2;
 800076e:	f3c3 4383 	ubfx	r3, r3, #18, #4
      if (pllsource == 0x00)
 8000772:	03cc      	lsls	r4, r1, #15
      pllmull = ( pllmull >> 18) + 2;
 8000774:	f103 0302 	add.w	r3, r3, #2
      if (pllsource == 0x00)
 8000778:	d402      	bmi.n	8000780 <RCC_GetClocksFreq+0x68>
          RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
 800077a:	4908      	ldr	r1, [pc, #32]	; (800079c <RCC_GetClocksFreq+0x84>)
          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;
 800077c:	434b      	muls	r3, r1
 800077e:	e7d5      	b.n	800072c <RCC_GetClocksFreq+0x14>
        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
 8000780:	6851      	ldr	r1, [r2, #4]
 8000782:	0389      	lsls	r1, r1, #14
 8000784:	d4f9      	bmi.n	800077a <RCC_GetClocksFreq+0x62>
          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;
 8000786:	4902      	ldr	r1, [pc, #8]	; (8000790 <RCC_GetClocksFreq+0x78>)
 8000788:	e7f8      	b.n	800077c <RCC_GetClocksFreq+0x64>
 800078a:	bf00      	nop
 800078c:	40021000 	.word	0x40021000
 8000790:	007a1200 	.word	0x007a1200
 8000794:	20000004 	.word	0x20000004
 8000798:	20000000 	.word	0x20000000
 800079c:	003d0900 	.word	0x003d0900

080007a0 <RCC_AHBPeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
{
 80007a0:	4b04      	ldr	r3, [pc, #16]	; (80007b4 <RCC_AHBPeriphClockCmd+0x14>)
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 80007a2:	695a      	ldr	r2, [r3, #20]
  if (NewState != DISABLE)
 80007a4:	b111      	cbz	r1, 80007ac <RCC_AHBPeriphClockCmd+0xc>
    RCC->AHBENR |= RCC_AHBPeriph;
 80007a6:	4310      	orrs	r0, r2
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
 80007a8:	6158      	str	r0, [r3, #20]
 80007aa:	4770      	bx	lr
 80007ac:	ea22 0000 	bic.w	r0, r2, r0
 80007b0:	e7fa      	b.n	80007a8 <RCC_AHBPeriphClockCmd+0x8>
 80007b2:	bf00      	nop
 80007b4:	40021000 	.word	0x40021000

080007b8 <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 80007b8:	4b04      	ldr	r3, [pc, #16]	; (80007cc <RCC_APB2PeriphClockCmd+0x14>)
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 80007ba:	699a      	ldr	r2, [r3, #24]
  if (NewState != DISABLE)
 80007bc:	b111      	cbz	r1, 80007c4 <RCC_APB2PeriphClockCmd+0xc>
    RCC->APB2ENR |= RCC_APB2Periph;
 80007be:	4310      	orrs	r0, r2
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 80007c0:	6198      	str	r0, [r3, #24]
 80007c2:	4770      	bx	lr
 80007c4:	ea22 0000 	bic.w	r0, r2, r0
 80007c8:	e7fa      	b.n	80007c0 <RCC_APB2PeriphClockCmd+0x8>
 80007ca:	bf00      	nop
 80007cc:	40021000 	.word	0x40021000

080007d0 <RCC_APB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 80007d0:	4b04      	ldr	r3, [pc, #16]	; (80007e4 <RCC_APB1PeriphClockCmd+0x14>)
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 80007d2:	69da      	ldr	r2, [r3, #28]
  if (NewState != DISABLE)
 80007d4:	b111      	cbz	r1, 80007dc <RCC_APB1PeriphClockCmd+0xc>
    RCC->APB1ENR |= RCC_APB1Periph;
 80007d6:	4310      	orrs	r0, r2
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 80007d8:	61d8      	str	r0, [r3, #28]
 80007da:	4770      	bx	lr
 80007dc:	ea22 0000 	bic.w	r0, r2, r0
 80007e0:	e7fa      	b.n	80007d8 <RCC_APB1PeriphClockCmd+0x8>
 80007e2:	bf00      	nop
 80007e4:	40021000 	.word	0x40021000

080007e8 <RCC_APB2PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 80007e8:	4b04      	ldr	r3, [pc, #16]	; (80007fc <RCC_APB2PeriphResetCmd+0x14>)
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 80007ea:	68da      	ldr	r2, [r3, #12]
  if (NewState != DISABLE)
 80007ec:	b111      	cbz	r1, 80007f4 <RCC_APB2PeriphResetCmd+0xc>
    RCC->APB2RSTR |= RCC_APB2Periph;
 80007ee:	4310      	orrs	r0, r2
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 80007f0:	60d8      	str	r0, [r3, #12]
 80007f2:	4770      	bx	lr
 80007f4:	ea22 0000 	bic.w	r0, r2, r0
 80007f8:	e7fa      	b.n	80007f0 <RCC_APB2PeriphResetCmd+0x8>
 80007fa:	bf00      	nop
 80007fc:	40021000 	.word	0x40021000

08000800 <RCC_APB1PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 8000800:	4b04      	ldr	r3, [pc, #16]	; (8000814 <RCC_APB1PeriphResetCmd+0x14>)
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 8000802:	691a      	ldr	r2, [r3, #16]
  if (NewState != DISABLE)
 8000804:	b111      	cbz	r1, 800080c <RCC_APB1PeriphResetCmd+0xc>
    RCC->APB1RSTR |= RCC_APB1Periph;
 8000806:	4310      	orrs	r0, r2
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 8000808:	6118      	str	r0, [r3, #16]
 800080a:	4770      	bx	lr
 800080c:	ea22 0000 	bic.w	r0, r2, r0
 8000810:	e7fa      	b.n	8000808 <RCC_APB1PeriphResetCmd+0x8>
 8000812:	bf00      	nop
 8000814:	40021000 	.word	0x40021000

08000818 <RCC_BackupResetCmd>:
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 8000818:	4b01      	ldr	r3, [pc, #4]	; (8000820 <RCC_BackupResetCmd+0x8>)
 800081a:	6018      	str	r0, [r3, #0]
 800081c:	4770      	bx	lr
 800081e:	bf00      	nop
 8000820:	42420440 	.word	0x42420440

08000824 <RCC_ClockSecuritySystemCmd>:
  */
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
 8000824:	4b01      	ldr	r3, [pc, #4]	; (800082c <RCC_ClockSecuritySystemCmd+0x8>)
 8000826:	6018      	str	r0, [r3, #0]
 8000828:	4770      	bx	lr
 800082a:	bf00      	nop
 800082c:	4242004c 	.word	0x4242004c

08000830 <RCC_MCOConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCO));

  /* Perform Byte access to MCO bits to select the MCO source */
  *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;
 8000830:	4b01      	ldr	r3, [pc, #4]	; (8000838 <RCC_MCOConfig+0x8>)
 8000832:	7018      	strb	r0, [r3, #0]
 8000834:	4770      	bx	lr
 8000836:	bf00      	nop
 8000838:	40021007 	.word	0x40021007

0800083c <RCC_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 800083c:	0942      	lsrs	r2, r0, #5
  if (tmp == 1)               /* The flag to check is in CR register */
 800083e:	2a01      	cmp	r2, #1
 8000840:	4b07      	ldr	r3, [pc, #28]	; (8000860 <RCC_GetFlagStatus+0x24>)
 8000842:	d107      	bne.n	8000854 <RCC_GetFlagStatus+0x18>
  {
    statusreg = RCC->CR;
 8000844:	681b      	ldr	r3, [r3, #0]
  {
    statusreg = RCC->CSR;
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_Mask;
 8000846:	f000 001f 	and.w	r0, r0, #31
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 800084a:	fa23 f000 	lsr.w	r0, r3, r0
    bitstatus = RESET;
  }

  /* Return the flag status */
  return bitstatus;
}
 800084e:	f000 0001 	and.w	r0, r0, #1
 8000852:	4770      	bx	lr
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 8000854:	2a02      	cmp	r2, #2
    statusreg = RCC->BDCR;
 8000856:	bf0c      	ite	eq
 8000858:	6a1b      	ldreq	r3, [r3, #32]
    statusreg = RCC->CSR;
 800085a:	6a5b      	ldrne	r3, [r3, #36]	; 0x24
 800085c:	e7f3      	b.n	8000846 <RCC_GetFlagStatus+0xa>
 800085e:	bf00      	nop
 8000860:	40021000 	.word	0x40021000

08000864 <RCC_WaitForHSEStartUp>:
  __IO uint32_t StartUpCounter = 0;
 8000864:	2300      	movs	r3, #0
{
 8000866:	b507      	push	{r0, r1, r2, lr}
  __IO uint32_t StartUpCounter = 0;
 8000868:	9301      	str	r3, [sp, #4]
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 800086a:	2031      	movs	r0, #49	; 0x31
 800086c:	f7ff ffe6 	bl	800083c <RCC_GetFlagStatus>
    StartUpCounter++;  
 8000870:	9b01      	ldr	r3, [sp, #4]
 8000872:	3301      	adds	r3, #1
 8000874:	9301      	str	r3, [sp, #4]
  } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
 8000876:	9b01      	ldr	r3, [sp, #4]
 8000878:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 800087c:	d001      	beq.n	8000882 <RCC_WaitForHSEStartUp+0x1e>
 800087e:	2800      	cmp	r0, #0
 8000880:	d0f3      	beq.n	800086a <RCC_WaitForHSEStartUp+0x6>
  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 8000882:	2031      	movs	r0, #49	; 0x31
 8000884:	f7ff ffda 	bl	800083c <RCC_GetFlagStatus>
}
 8000888:	3000      	adds	r0, #0
 800088a:	bf18      	it	ne
 800088c:	2001      	movne	r0, #1
 800088e:	b003      	add	sp, #12
 8000890:	f85d fb04 	ldr.w	pc, [sp], #4

08000894 <RCC_ClearFlag>:
  * @retval None
  */
void RCC_ClearFlag(void)
{
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= CSR_RMVF_Set;
 8000894:	4a02      	ldr	r2, [pc, #8]	; (80008a0 <RCC_ClearFlag+0xc>)
 8000896:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8000898:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800089c:	6253      	str	r3, [r2, #36]	; 0x24
 800089e:	4770      	bx	lr
 80008a0:	40021000 	.word	0x40021000

080008a4 <RCC_GetITStatus>:
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 80008a4:	4b03      	ldr	r3, [pc, #12]	; (80008b4 <RCC_GetITStatus+0x10>)
 80008a6:	689b      	ldr	r3, [r3, #8]
 80008a8:	4218      	tst	r0, r3
    bitstatus = RESET;
  }

  /* Return the RCC_IT status */
  return  bitstatus;
}
 80008aa:	bf14      	ite	ne
 80008ac:	2001      	movne	r0, #1
 80008ae:	2000      	moveq	r0, #0
 80008b0:	4770      	bx	lr
 80008b2:	bf00      	nop
 80008b4:	40021000 	.word	0x40021000

080008b8 <RCC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
 80008b8:	4b01      	ldr	r3, [pc, #4]	; (80008c0 <RCC_ClearITPendingBit+0x8>)
 80008ba:	7018      	strb	r0, [r3, #0]
 80008bc:	4770      	bx	lr
 80008be:	bf00      	nop
 80008c0:	4002100a 	.word	0x4002100a

080008c4 <SystemInit>:
  */
void SystemInit (void)
{
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80008c4:	4b37      	ldr	r3, [pc, #220]	; (80009a4 <SystemInit+0xe0>)
{
 80008c6:	b082      	sub	sp, #8
  RCC->CR |= (uint32_t)0x00000001;
 80008c8:	681a      	ldr	r2, [r3, #0]
 80008ca:	f042 0201 	orr.w	r2, r2, #1
 80008ce:	601a      	str	r2, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 80008d0:	6859      	ldr	r1, [r3, #4]
 80008d2:	4a35      	ldr	r2, [pc, #212]	; (80009a8 <SystemInit+0xe4>)
 80008d4:	400a      	ands	r2, r1
 80008d6:	605a      	str	r2, [r3, #4]
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80008d8:	681a      	ldr	r2, [r3, #0]
 80008da:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 80008de:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80008e2:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80008e4:	681a      	ldr	r2, [r3, #0]
 80008e6:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80008ea:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 80008ec:	685a      	ldr	r2, [r3, #4]
 80008ee:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 80008f2:	605a      	str	r2, [r3, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 80008f4:	f44f 021f 	mov.w	r2, #10420224	; 0x9f0000
 80008f8:	609a      	str	r2, [r3, #8]
  * @param  None
  * @retval None
  */
static void SetSysClockTo72(void)
{
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 80008fa:	2200      	movs	r2, #0
 80008fc:	9200      	str	r2, [sp, #0]
 80008fe:	9201      	str	r2, [sp, #4]
  
  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
  /* Enable HSE */    
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8000900:	681a      	ldr	r2, [r3, #0]
 8000902:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8000906:	601a      	str	r2, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 8000908:	681a      	ldr	r2, [r3, #0]
 800090a:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 800090e:	9201      	str	r2, [sp, #4]
    StartUpCounter++;  
 8000910:	9a00      	ldr	r2, [sp, #0]
 8000912:	3201      	adds	r2, #1
 8000914:	9200      	str	r2, [sp, #0]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8000916:	9a01      	ldr	r2, [sp, #4]
 8000918:	b91a      	cbnz	r2, 8000922 <SystemInit+0x5e>
 800091a:	9a00      	ldr	r2, [sp, #0]
 800091c:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 8000920:	d1f2      	bne.n	8000908 <SystemInit+0x44>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 8000922:	681a      	ldr	r2, [r3, #0]
 8000924:	f412 3200 	ands.w	r2, r2, #131072	; 0x20000
  {
    HSEStatus = (uint32_t)0x01;
 8000928:	bf18      	it	ne
 800092a:	2201      	movne	r2, #1
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 800092c:	9201      	str	r2, [sp, #4]
  }  

  if (HSEStatus == (uint32_t)0x01)
 800092e:	9a01      	ldr	r2, [sp, #4]
 8000930:	2a01      	cmp	r2, #1
 8000932:	d005      	beq.n	8000940 <SystemInit+0x7c>
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 8000934:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8000938:	4b1c      	ldr	r3, [pc, #112]	; (80009ac <SystemInit+0xe8>)
 800093a:	609a      	str	r2, [r3, #8]
}
 800093c:	b002      	add	sp, #8
 800093e:	4770      	bx	lr
  {
    /* Enable Prefetch Buffer */
    FLASH->ACR |= FLASH_ACR_PRFTBE;
 8000940:	4a1b      	ldr	r2, [pc, #108]	; (80009b0 <SystemInit+0xec>)
 8000942:	6811      	ldr	r1, [r2, #0]
 8000944:	f041 0110 	orr.w	r1, r1, #16
 8000948:	6011      	str	r1, [r2, #0]

    /* Flash 2 wait state */
    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
 800094a:	6811      	ldr	r1, [r2, #0]
 800094c:	f021 0103 	bic.w	r1, r1, #3
 8000950:	6011      	str	r1, [r2, #0]
    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
 8000952:	6811      	ldr	r1, [r2, #0]
 8000954:	f041 0102 	orr.w	r1, r1, #2
 8000958:	6011      	str	r1, [r2, #0]

 
    /* HCLK = SYSCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
 800095a:	685a      	ldr	r2, [r3, #4]
 800095c:	605a      	str	r2, [r3, #4]
      
    /* PCLK2 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
 800095e:	685a      	ldr	r2, [r3, #4]
 8000960:	605a      	str	r2, [r3, #4]
    
    /* PCLK1 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
 8000962:	685a      	ldr	r2, [r3, #4]
 8000964:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000968:	605a      	str	r2, [r3, #4]
    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
                            RCC_CFGR_PLLMULL9); 
#else    
    /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
 800096a:	685a      	ldr	r2, [r3, #4]
 800096c:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
 8000970:	605a      	str	r2, [r3, #4]
                                        RCC_CFGR_PLLMULL));
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
 8000972:	685a      	ldr	r2, [r3, #4]
 8000974:	f442 12e8 	orr.w	r2, r2, #1900544	; 0x1d0000
 8000978:	605a      	str	r2, [r3, #4]
#endif /* STM32F10X_CL */

    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;
 800097a:	681a      	ldr	r2, [r3, #0]
 800097c:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8000980:	601a      	str	r2, [r3, #0]

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 8000982:	681a      	ldr	r2, [r3, #0]
 8000984:	0192      	lsls	r2, r2, #6
 8000986:	d5fc      	bpl.n	8000982 <SystemInit+0xbe>
    {
    }
    
    /* Select PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 8000988:	685a      	ldr	r2, [r3, #4]
 800098a:	f022 0203 	bic.w	r2, r2, #3
 800098e:	605a      	str	r2, [r3, #4]
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
 8000990:	685a      	ldr	r2, [r3, #4]
 8000992:	f042 0202 	orr.w	r2, r2, #2
 8000996:	605a      	str	r2, [r3, #4]

    /* Wait till PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
 8000998:	685a      	ldr	r2, [r3, #4]
 800099a:	f002 020c 	and.w	r2, r2, #12
 800099e:	2a08      	cmp	r2, #8
 80009a0:	d1fa      	bne.n	8000998 <SystemInit+0xd4>
 80009a2:	e7c7      	b.n	8000934 <SystemInit+0x70>
 80009a4:	40021000 	.word	0x40021000
 80009a8:	f8ff0000 	.word	0xf8ff0000
 80009ac:	e000ed00 	.word	0xe000ed00
 80009b0:	40022000 	.word	0x40022000

080009b4 <SystemCoreClockUpdate>:
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 80009b4:	4a11      	ldr	r2, [pc, #68]	; (80009fc <SystemCoreClockUpdate+0x48>)
 80009b6:	4b12      	ldr	r3, [pc, #72]	; (8000a00 <SystemCoreClockUpdate+0x4c>)
 80009b8:	6851      	ldr	r1, [r2, #4]
 80009ba:	f001 010c 	and.w	r1, r1, #12
  switch (tmp)
 80009be:	2904      	cmp	r1, #4
 80009c0:	d001      	beq.n	80009c6 <SystemCoreClockUpdate+0x12>
 80009c2:	2908      	cmp	r1, #8
 80009c4:	d00a      	beq.n	80009dc <SystemCoreClockUpdate+0x28>
      SystemCoreClock = HSE_VALUE;
 80009c6:	490f      	ldr	r1, [pc, #60]	; (8000a04 <SystemCoreClockUpdate+0x50>)
          SystemCoreClock = HSE_VALUE * pllmull;
 80009c8:	6019      	str	r1, [r3, #0]
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 80009ca:	6852      	ldr	r2, [r2, #4]
 80009cc:	490e      	ldr	r1, [pc, #56]	; (8000a08 <SystemCoreClockUpdate+0x54>)
 80009ce:	f3c2 1203 	ubfx	r2, r2, #4, #4
 80009d2:	5c89      	ldrb	r1, [r1, r2]
  SystemCoreClock >>= tmp;  
 80009d4:	681a      	ldr	r2, [r3, #0]
 80009d6:	40ca      	lsrs	r2, r1
 80009d8:	601a      	str	r2, [r3, #0]
 80009da:	4770      	bx	lr
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
 80009dc:	6851      	ldr	r1, [r2, #4]
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
 80009de:	6850      	ldr	r0, [r2, #4]
      pllmull = ( pllmull >> 18) + 2;
 80009e0:	f3c1 4183 	ubfx	r1, r1, #18, #4
      if (pllsource == 0x00)
 80009e4:	03c0      	lsls	r0, r0, #15
      pllmull = ( pllmull >> 18) + 2;
 80009e6:	f101 0102 	add.w	r1, r1, #2
      if (pllsource == 0x00)
 80009ea:	d402      	bmi.n	80009f2 <SystemCoreClockUpdate+0x3e>
          SystemCoreClock = (HSE_VALUE >> 1) * pllmull;
 80009ec:	4807      	ldr	r0, [pc, #28]	; (8000a0c <SystemCoreClockUpdate+0x58>)
          SystemCoreClock = HSE_VALUE * pllmull;
 80009ee:	4341      	muls	r1, r0
 80009f0:	e7ea      	b.n	80009c8 <SystemCoreClockUpdate+0x14>
        if ((RCC->CFGR & RCC_CFGR_PLLXTPRE) != (uint32_t)RESET)
 80009f2:	6850      	ldr	r0, [r2, #4]
 80009f4:	0380      	lsls	r0, r0, #14
 80009f6:	d4f9      	bmi.n	80009ec <SystemCoreClockUpdate+0x38>
          SystemCoreClock = HSE_VALUE * pllmull;
 80009f8:	4802      	ldr	r0, [pc, #8]	; (8000a04 <SystemCoreClockUpdate+0x50>)
 80009fa:	e7f8      	b.n	80009ee <SystemCoreClockUpdate+0x3a>
 80009fc:	40021000 	.word	0x40021000
 8000a00:	20000024 	.word	0x20000024
 8000a04:	007a1200 	.word	0x007a1200
 8000a08:	20000014 	.word	0x20000014
 8000a0c:	003d0900 	.word	0x003d0900

08000a10 <prvTaskIsTaskSuspended>:

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 8000a10:	6942      	ldr	r2, [r0, #20]
 8000a12:	4b06      	ldr	r3, [pc, #24]	; (8000a2c <prvTaskIsTaskSuspended+0x1c>)
 8000a14:	429a      	cmp	r2, r3
 8000a16:	d001      	beq.n	8000a1c <prvTaskIsTaskSuspended+0xc>
	BaseType_t xReturn = pdFALSE;
 8000a18:	2000      	movs	r0, #0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 8000a1a:	4770      	bx	lr
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 8000a1c:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8000a1e:	4b04      	ldr	r3, [pc, #16]	; (8000a30 <prvTaskIsTaskSuspended+0x20>)
 8000a20:	4298      	cmp	r0, r3
 8000a22:	d0f9      	beq.n	8000a18 <prvTaskIsTaskSuspended+0x8>
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
 8000a24:	fab0 f080 	clz	r0, r0
 8000a28:	0940      	lsrs	r0, r0, #5
		return xReturn;
 8000a2a:	4770      	bx	lr
 8000a2c:	2000011c 	.word	0x2000011c
 8000a30:	20000104 	.word	0x20000104

08000a34 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8000a34:	4a06      	ldr	r2, [pc, #24]	; (8000a50 <prvResetNextTaskUnblockTime+0x1c>)
 8000a36:	6813      	ldr	r3, [r2, #0]
 8000a38:	6819      	ldr	r1, [r3, #0]
 8000a3a:	4b06      	ldr	r3, [pc, #24]	; (8000a54 <prvResetNextTaskUnblockTime+0x20>)
 8000a3c:	b919      	cbnz	r1, 8000a46 <prvResetNextTaskUnblockTime+0x12>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 8000a3e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8000a42:	601a      	str	r2, [r3, #0]
 8000a44:	4770      	bx	lr
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8000a46:	6812      	ldr	r2, [r2, #0]
 8000a48:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8000a4a:	68d2      	ldr	r2, [r2, #12]
 8000a4c:	6852      	ldr	r2, [r2, #4]
 8000a4e:	e7f8      	b.n	8000a42 <prvResetNextTaskUnblockTime+0xe>
 8000a50:	2000004c 	.word	0x2000004c
 8000a54:	200000fc 	.word	0x200000fc

08000a58 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8000a58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 8000a5a:	4b1b      	ldr	r3, [pc, #108]	; (8000ac8 <prvAddCurrentTaskToDelayedList+0x70>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8000a5c:	4e1b      	ldr	r6, [pc, #108]	; (8000acc <prvAddCurrentTaskToDelayedList+0x74>)
const TickType_t xConstTickCount = xTickCount;
 8000a5e:	681d      	ldr	r5, [r3, #0]
{
 8000a60:	4604      	mov	r4, r0
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8000a62:	6830      	ldr	r0, [r6, #0]
{
 8000a64:	460f      	mov	r7, r1
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8000a66:	3004      	adds	r0, #4
 8000a68:	f001 fa9b 	bl	8001fa2 <uxListRemove>
 8000a6c:	4633      	mov	r3, r6
 8000a6e:	b940      	cbnz	r0, 8000a82 <prvAddCurrentTaskToDelayedList+0x2a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 8000a70:	2001      	movs	r0, #1
 8000a72:	6831      	ldr	r1, [r6, #0]
 8000a74:	4e16      	ldr	r6, [pc, #88]	; (8000ad0 <prvAddCurrentTaskToDelayedList+0x78>)
 8000a76:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 8000a78:	6832      	ldr	r2, [r6, #0]
 8000a7a:	4088      	lsls	r0, r1
 8000a7c:	ea22 0200 	bic.w	r2, r2, r0
 8000a80:	6032      	str	r2, [r6, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8000a82:	1c62      	adds	r2, r4, #1
 8000a84:	d107      	bne.n	8000a96 <prvAddCurrentTaskToDelayedList+0x3e>
 8000a86:	b137      	cbz	r7, 8000a96 <prvAddCurrentTaskToDelayedList+0x3e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8000a88:	6819      	ldr	r1, [r3, #0]
 8000a8a:	4812      	ldr	r0, [pc, #72]	; (8000ad4 <prvAddCurrentTaskToDelayedList+0x7c>)
 8000a8c:	3104      	adds	r1, #4

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8000a8e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8000a92:	f001 ba63 	b.w	8001f5c <vListInsertEnd>
			xTimeToWake = xConstTickCount + xTicksToWait;
 8000a96:	442c      	add	r4, r5
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8000a98:	681a      	ldr	r2, [r3, #0]
			if( xTimeToWake < xConstTickCount )
 8000a9a:	42a5      	cmp	r5, r4
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8000a9c:	6054      	str	r4, [r2, #4]
			if( xTimeToWake < xConstTickCount )
 8000a9e:	d907      	bls.n	8000ab0 <prvAddCurrentTaskToDelayedList+0x58>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8000aa0:	4a0d      	ldr	r2, [pc, #52]	; (8000ad8 <prvAddCurrentTaskToDelayedList+0x80>)
 8000aa2:	6810      	ldr	r0, [r2, #0]
 8000aa4:	6819      	ldr	r1, [r3, #0]
}
 8000aa6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8000aaa:	3104      	adds	r1, #4
 8000aac:	f001 ba62 	b.w	8001f74 <vListInsert>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8000ab0:	4a0a      	ldr	r2, [pc, #40]	; (8000adc <prvAddCurrentTaskToDelayedList+0x84>)
 8000ab2:	6810      	ldr	r0, [r2, #0]
 8000ab4:	6819      	ldr	r1, [r3, #0]
 8000ab6:	3104      	adds	r1, #4
 8000ab8:	f001 fa5c 	bl	8001f74 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 8000abc:	4b08      	ldr	r3, [pc, #32]	; (8000ae0 <prvAddCurrentTaskToDelayedList+0x88>)
 8000abe:	681a      	ldr	r2, [r3, #0]
 8000ac0:	4294      	cmp	r4, r2
					xNextTaskUnblockTime = xTimeToWake;
 8000ac2:	bf38      	it	cc
 8000ac4:	601c      	strcc	r4, [r3, #0]
 8000ac6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000ac8:	20000144 	.word	0x20000144
 8000acc:	20000048 	.word	0x20000048
 8000ad0:	200000cc 	.word	0x200000cc
 8000ad4:	2000011c 	.word	0x2000011c
 8000ad8:	20000050 	.word	0x20000050
 8000adc:	2000004c 	.word	0x2000004c
 8000ae0:	200000fc 	.word	0x200000fc

08000ae4 <xTaskCreate>:
	{
 8000ae4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000ae8:	ea4f 0a82 	mov.w	sl, r2, lsl #2
	{
 8000aec:	4680      	mov	r8, r0
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000aee:	4650      	mov	r0, sl
	{
 8000af0:	460d      	mov	r5, r1
 8000af2:	4699      	mov	r9, r3
 8000af4:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000af6:	f001 f975 	bl	8001de4 <pvPortMalloc>
			if( pxStack != NULL )
 8000afa:	4607      	mov	r7, r0
 8000afc:	2800      	cmp	r0, #0
 8000afe:	f000 80a6 	beq.w	8000c4e <xTaskCreate+0x16a>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 8000b02:	205c      	movs	r0, #92	; 0x5c
 8000b04:	f001 f96e 	bl	8001de4 <pvPortMalloc>
				if( pxNewTCB != NULL )
 8000b08:	4604      	mov	r4, r0
 8000b0a:	2800      	cmp	r0, #0
 8000b0c:	f000 809c 	beq.w	8000c48 <xTaskCreate+0x164>
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8000b10:	4652      	mov	r2, sl
					pxNewTCB->pxStack = pxStack;
 8000b12:	6307      	str	r7, [r0, #48]	; 0x30
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8000b14:	21a5      	movs	r1, #165	; 0xa5
 8000b16:	4638      	mov	r0, r7
 8000b18:	f001 fa99 	bl	800204e <memset>
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8000b1c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000b1e:	f1aa 0a04 	sub.w	sl, sl, #4
 8000b22:	449a      	add	sl, r3
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8000b24:	f02a 0a07 	bic.w	sl, sl, #7
 8000b28:	1e6b      	subs	r3, r5, #1
 8000b2a:	f104 0234 	add.w	r2, r4, #52	; 0x34
 8000b2e:	350f      	adds	r5, #15
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8000b30:	7859      	ldrb	r1, [r3, #1]
 8000b32:	f802 1b01 	strb.w	r1, [r2], #1
		if( pcName[ x ] == 0x00 )
 8000b36:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 8000b3a:	b109      	cbz	r1, 8000b40 <xTaskCreate+0x5c>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8000b3c:	42ab      	cmp	r3, r5
 8000b3e:	d1f7      	bne.n	8000b30 <xTaskCreate+0x4c>
 8000b40:	9d0a      	ldr	r5, [sp, #40]	; 0x28
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8000b42:	f04f 0b00 	mov.w	fp, #0
 8000b46:	2d04      	cmp	r5, #4
 8000b48:	bf28      	it	cs
 8000b4a:	2504      	movcs	r5, #4
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8000b4c:	1d27      	adds	r7, r4, #4
	pxNewTCB->uxPriority = uxPriority;
 8000b4e:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 8000b50:	64e5      	str	r5, [r4, #76]	; 0x4c
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8000b52:	4638      	mov	r0, r7
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8000b54:	f884 b043 	strb.w	fp, [r4, #67]	; 0x43
		pxNewTCB->uxMutexesHeld = 0;
 8000b58:	f8c4 b050 	str.w	fp, [r4, #80]	; 0x50
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8000b5c:	f001 f9fb 	bl	8001f56 <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000b60:	f1c5 0505 	rsb	r5, r5, #5
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8000b64:	f104 0018 	add.w	r0, r4, #24
 8000b68:	f001 f9f5 	bl	8001f56 <vListInitialiseItem>
		pxNewTCB->ulNotifiedValue = 0;
 8000b6c:	f8c4 b054 	str.w	fp, [r4, #84]	; 0x54
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8000b70:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000b72:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8000b74:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8000b76:	f884 b058 	strb.w	fp, [r4, #88]	; 0x58
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8000b7a:	464a      	mov	r2, r9
 8000b7c:	4641      	mov	r1, r8
 8000b7e:	4650      	mov	r0, sl
 8000b80:	f001 f86c 	bl	8001c5c <pxPortInitialiseStack>
 8000b84:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 8000b86:	b106      	cbz	r6, 8000b8a <xTaskCreate+0xa6>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8000b88:	6034      	str	r4, [r6, #0]
	taskENTER_CRITICAL();
 8000b8a:	f001 f88c 	bl	8001ca6 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 8000b8e:	4b37      	ldr	r3, [pc, #220]	; (8000c6c <xTaskCreate+0x188>)
		if( pxCurrentTCB == NULL )
 8000b90:	4e37      	ldr	r6, [pc, #220]	; (8000c70 <xTaskCreate+0x18c>)
		uxCurrentNumberOfTasks++;
 8000b92:	681a      	ldr	r2, [r3, #0]
 8000b94:	f8df 8114 	ldr.w	r8, [pc, #276]	; 8000cac <xTaskCreate+0x1c8>
 8000b98:	3201      	adds	r2, #1
 8000b9a:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
 8000b9c:	6832      	ldr	r2, [r6, #0]
 8000b9e:	2a00      	cmp	r2, #0
 8000ba0:	d158      	bne.n	8000c54 <xTaskCreate+0x170>
			pxCurrentTCB = pxNewTCB;
 8000ba2:	6034      	str	r4, [r6, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8000ba4:	681b      	ldr	r3, [r3, #0]
 8000ba6:	2b01      	cmp	r3, #1
 8000ba8:	d125      	bne.n	8000bf6 <xTaskCreate+0x112>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8000baa:	4832      	ldr	r0, [pc, #200]	; (8000c74 <xTaskCreate+0x190>)
 8000bac:	f001 f9c8 	bl	8001f40 <vListInitialise>
 8000bb0:	4831      	ldr	r0, [pc, #196]	; (8000c78 <xTaskCreate+0x194>)
 8000bb2:	f001 f9c5 	bl	8001f40 <vListInitialise>
 8000bb6:	4831      	ldr	r0, [pc, #196]	; (8000c7c <xTaskCreate+0x198>)
 8000bb8:	f001 f9c2 	bl	8001f40 <vListInitialise>
	vListInitialise( &xDelayedTaskList1 );
 8000bbc:	f8df 90f0 	ldr.w	r9, [pc, #240]	; 8000cb0 <xTaskCreate+0x1cc>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8000bc0:	482f      	ldr	r0, [pc, #188]	; (8000c80 <xTaskCreate+0x19c>)
 8000bc2:	f001 f9bd 	bl	8001f40 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8000bc6:	4d2f      	ldr	r5, [pc, #188]	; (8000c84 <xTaskCreate+0x1a0>)
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8000bc8:	482f      	ldr	r0, [pc, #188]	; (8000c88 <xTaskCreate+0x1a4>)
 8000bca:	f001 f9b9 	bl	8001f40 <vListInitialise>
	vListInitialise( &xDelayedTaskList1 );
 8000bce:	4648      	mov	r0, r9
 8000bd0:	f001 f9b6 	bl	8001f40 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8000bd4:	4628      	mov	r0, r5
 8000bd6:	f001 f9b3 	bl	8001f40 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8000bda:	482c      	ldr	r0, [pc, #176]	; (8000c8c <xTaskCreate+0x1a8>)
 8000bdc:	f001 f9b0 	bl	8001f40 <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 8000be0:	482b      	ldr	r0, [pc, #172]	; (8000c90 <xTaskCreate+0x1ac>)
 8000be2:	f001 f9ad 	bl	8001f40 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 8000be6:	482b      	ldr	r0, [pc, #172]	; (8000c94 <xTaskCreate+0x1b0>)
 8000be8:	f001 f9aa 	bl	8001f40 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 8000bec:	4b2a      	ldr	r3, [pc, #168]	; (8000c98 <xTaskCreate+0x1b4>)
 8000bee:	f8c3 9000 	str.w	r9, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8000bf2:	4b2a      	ldr	r3, [pc, #168]	; (8000c9c <xTaskCreate+0x1b8>)
 8000bf4:	601d      	str	r5, [r3, #0]
		prvAddTaskToReadyList( pxNewTCB );
 8000bf6:	2501      	movs	r5, #1
		uxTaskNumber++;
 8000bf8:	4a29      	ldr	r2, [pc, #164]	; (8000ca0 <xTaskCreate+0x1bc>)
		prvAddTaskToReadyList( pxNewTCB );
 8000bfa:	492a      	ldr	r1, [pc, #168]	; (8000ca4 <xTaskCreate+0x1c0>)
		uxTaskNumber++;
 8000bfc:	6813      	ldr	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 8000bfe:	6808      	ldr	r0, [r1, #0]
		uxTaskNumber++;
 8000c00:	3301      	adds	r3, #1
 8000c02:	6013      	str	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 8000c04:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 8000c06:	6463      	str	r3, [r4, #68]	; 0x44
		prvAddTaskToReadyList( pxNewTCB );
 8000c08:	fa05 f302 	lsl.w	r3, r5, r2
 8000c0c:	4303      	orrs	r3, r0
 8000c0e:	2014      	movs	r0, #20
 8000c10:	600b      	str	r3, [r1, #0]
 8000c12:	4b18      	ldr	r3, [pc, #96]	; (8000c74 <xTaskCreate+0x190>)
 8000c14:	4639      	mov	r1, r7
 8000c16:	fb00 3002 	mla	r0, r0, r2, r3
 8000c1a:	f001 f99f 	bl	8001f5c <vListInsertEnd>
	taskEXIT_CRITICAL();
 8000c1e:	f001 f851 	bl	8001cc4 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 8000c22:	f8d8 3000 	ldr.w	r3, [r8]
 8000c26:	b163      	cbz	r3, 8000c42 <xTaskCreate+0x15e>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8000c28:	6833      	ldr	r3, [r6, #0]
 8000c2a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000c2c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8000c2e:	429a      	cmp	r2, r3
 8000c30:	d207      	bcs.n	8000c42 <xTaskCreate+0x15e>
			taskYIELD_IF_USING_PREEMPTION();
 8000c32:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000c36:	4b1c      	ldr	r3, [pc, #112]	; (8000ca8 <xTaskCreate+0x1c4>)
 8000c38:	601a      	str	r2, [r3, #0]
 8000c3a:	f3bf 8f4f 	dsb	sy
 8000c3e:	f3bf 8f6f 	isb	sy
	}
 8000c42:	4628      	mov	r0, r5
 8000c44:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					vPortFree( pxStack );
 8000c48:	4638      	mov	r0, r7
 8000c4a:	f001 f945 	bl	8001ed8 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8000c4e:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 8000c52:	e7f6      	b.n	8000c42 <xTaskCreate+0x15e>
			if( xSchedulerRunning == pdFALSE )
 8000c54:	f8d8 3000 	ldr.w	r3, [r8]
 8000c58:	2b00      	cmp	r3, #0
 8000c5a:	d1cc      	bne.n	8000bf6 <xTaskCreate+0x112>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8000c5c:	6833      	ldr	r3, [r6, #0]
 8000c5e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000c60:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8000c62:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
 8000c64:	bf98      	it	ls
 8000c66:	6034      	strls	r4, [r6, #0]
 8000c68:	e7c5      	b.n	8000bf6 <xTaskCreate+0x112>
 8000c6a:	bf00      	nop
 8000c6c:	200000b8 	.word	0x200000b8
 8000c70:	20000048 	.word	0x20000048
 8000c74:	20000054 	.word	0x20000054
 8000c78:	20000068 	.word	0x20000068
 8000c7c:	2000007c 	.word	0x2000007c
 8000c80:	20000090 	.word	0x20000090
 8000c84:	200000e4 	.word	0x200000e4
 8000c88:	200000a4 	.word	0x200000a4
 8000c8c:	20000104 	.word	0x20000104
 8000c90:	20000130 	.word	0x20000130
 8000c94:	2000011c 	.word	0x2000011c
 8000c98:	2000004c 	.word	0x2000004c
 8000c9c:	20000050 	.word	0x20000050
 8000ca0:	200000c8 	.word	0x200000c8
 8000ca4:	200000cc 	.word	0x200000cc
 8000ca8:	e000ed04 	.word	0xe000ed04
 8000cac:	20000118 	.word	0x20000118
 8000cb0:	200000d0 	.word	0x200000d0

08000cb4 <vTaskDelete>:
	{
 8000cb4:	b570      	push	{r4, r5, r6, lr}
 8000cb6:	4604      	mov	r4, r0
 8000cb8:	4d24      	ldr	r5, [pc, #144]	; (8000d4c <vTaskDelete+0x98>)
		taskENTER_CRITICAL();
 8000cba:	f000 fff4 	bl	8001ca6 <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 8000cbe:	b904      	cbnz	r4, 8000cc2 <vTaskDelete+0xe>
 8000cc0:	682c      	ldr	r4, [r5, #0]
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8000cc2:	1d26      	adds	r6, r4, #4
 8000cc4:	4630      	mov	r0, r6
 8000cc6:	f001 f96c 	bl	8001fa2 <uxListRemove>
 8000cca:	b960      	cbnz	r0, 8000ce6 <vTaskDelete+0x32>
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8000ccc:	2114      	movs	r1, #20
 8000cce:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8000cd0:	4b1f      	ldr	r3, [pc, #124]	; (8000d50 <vTaskDelete+0x9c>)
 8000cd2:	4341      	muls	r1, r0
 8000cd4:	585b      	ldr	r3, [r3, r1]
 8000cd6:	b933      	cbnz	r3, 8000ce6 <vTaskDelete+0x32>
 8000cd8:	2201      	movs	r2, #1
 8000cda:	491e      	ldr	r1, [pc, #120]	; (8000d54 <vTaskDelete+0xa0>)
 8000cdc:	4082      	lsls	r2, r0
 8000cde:	680b      	ldr	r3, [r1, #0]
 8000ce0:	ea23 0302 	bic.w	r3, r3, r2
 8000ce4:	600b      	str	r3, [r1, #0]
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8000ce6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8000ce8:	b11b      	cbz	r3, 8000cf2 <vTaskDelete+0x3e>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8000cea:	f104 0018 	add.w	r0, r4, #24
 8000cee:	f001 f958 	bl	8001fa2 <uxListRemove>
			uxTaskNumber++;
 8000cf2:	4a19      	ldr	r2, [pc, #100]	; (8000d58 <vTaskDelete+0xa4>)
 8000cf4:	6813      	ldr	r3, [r2, #0]
 8000cf6:	3301      	adds	r3, #1
 8000cf8:	6013      	str	r3, [r2, #0]
			if( pxTCB == pxCurrentTCB )
 8000cfa:	682b      	ldr	r3, [r5, #0]
 8000cfc:	429c      	cmp	r4, r3
 8000cfe:	d118      	bne.n	8000d32 <vTaskDelete+0x7e>
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 8000d00:	4631      	mov	r1, r6
 8000d02:	4816      	ldr	r0, [pc, #88]	; (8000d5c <vTaskDelete+0xa8>)
 8000d04:	f001 f92a 	bl	8001f5c <vListInsertEnd>
				++uxDeletedTasksWaitingCleanUp;
 8000d08:	4a15      	ldr	r2, [pc, #84]	; (8000d60 <vTaskDelete+0xac>)
 8000d0a:	6813      	ldr	r3, [r2, #0]
 8000d0c:	3301      	adds	r3, #1
 8000d0e:	6013      	str	r3, [r2, #0]
		taskEXIT_CRITICAL();
 8000d10:	f000 ffd8 	bl	8001cc4 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
 8000d14:	4b13      	ldr	r3, [pc, #76]	; (8000d64 <vTaskDelete+0xb0>)
 8000d16:	681b      	ldr	r3, [r3, #0]
 8000d18:	b153      	cbz	r3, 8000d30 <vTaskDelete+0x7c>
			if( pxTCB == pxCurrentTCB )
 8000d1a:	682b      	ldr	r3, [r5, #0]
 8000d1c:	429c      	cmp	r4, r3
 8000d1e:	d107      	bne.n	8000d30 <vTaskDelete+0x7c>
				portYIELD_WITHIN_API();
 8000d20:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000d24:	4b10      	ldr	r3, [pc, #64]	; (8000d68 <vTaskDelete+0xb4>)
 8000d26:	601a      	str	r2, [r3, #0]
 8000d28:	f3bf 8f4f 	dsb	sy
 8000d2c:	f3bf 8f6f 	isb	sy
 8000d30:	bd70      	pop	{r4, r5, r6, pc}
				--uxCurrentNumberOfTasks;
 8000d32:	4a0e      	ldr	r2, [pc, #56]	; (8000d6c <vTaskDelete+0xb8>)
			vPortFree( pxTCB->pxStack );
 8000d34:	6b20      	ldr	r0, [r4, #48]	; 0x30
				--uxCurrentNumberOfTasks;
 8000d36:	6813      	ldr	r3, [r2, #0]
 8000d38:	3b01      	subs	r3, #1
 8000d3a:	6013      	str	r3, [r2, #0]
			vPortFree( pxTCB->pxStack );
 8000d3c:	f001 f8cc 	bl	8001ed8 <vPortFree>
			vPortFree( pxTCB );
 8000d40:	4620      	mov	r0, r4
 8000d42:	f001 f8c9 	bl	8001ed8 <vPortFree>
				prvResetNextTaskUnblockTime();
 8000d46:	f7ff fe75 	bl	8000a34 <prvResetNextTaskUnblockTime>
 8000d4a:	e7e1      	b.n	8000d10 <vTaskDelete+0x5c>
 8000d4c:	20000048 	.word	0x20000048
 8000d50:	20000054 	.word	0x20000054
 8000d54:	200000cc 	.word	0x200000cc
 8000d58:	200000c8 	.word	0x200000c8
 8000d5c:	20000130 	.word	0x20000130
 8000d60:	200000bc 	.word	0x200000bc
 8000d64:	20000118 	.word	0x20000118
 8000d68:	e000ed04 	.word	0xe000ed04
 8000d6c:	200000b8 	.word	0x200000b8

08000d70 <eTaskGetState>:
	{
 8000d70:	b538      	push	{r3, r4, r5, lr}
		if( pxTCB == pxCurrentTCB )
 8000d72:	4b14      	ldr	r3, [pc, #80]	; (8000dc4 <eTaskGetState+0x54>)
	{
 8000d74:	4605      	mov	r5, r0
		if( pxTCB == pxCurrentTCB )
 8000d76:	681b      	ldr	r3, [r3, #0]
 8000d78:	4298      	cmp	r0, r3
 8000d7a:	d01d      	beq.n	8000db8 <eTaskGetState+0x48>
			taskENTER_CRITICAL();
 8000d7c:	f000 ff93 	bl	8001ca6 <vPortEnterCritical>
				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
 8000d80:	696c      	ldr	r4, [r5, #20]
			taskEXIT_CRITICAL();
 8000d82:	f000 ff9f 	bl	8001cc4 <vPortExitCritical>
			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
 8000d86:	4b10      	ldr	r3, [pc, #64]	; (8000dc8 <eTaskGetState+0x58>)
 8000d88:	681b      	ldr	r3, [r3, #0]
 8000d8a:	429c      	cmp	r4, r3
 8000d8c:	d016      	beq.n	8000dbc <eTaskGetState+0x4c>
 8000d8e:	4b0f      	ldr	r3, [pc, #60]	; (8000dcc <eTaskGetState+0x5c>)
 8000d90:	681b      	ldr	r3, [r3, #0]
 8000d92:	429c      	cmp	r4, r3
 8000d94:	d012      	beq.n	8000dbc <eTaskGetState+0x4c>
				else if( pxStateList == &xSuspendedTaskList )
 8000d96:	4b0e      	ldr	r3, [pc, #56]	; (8000dd0 <eTaskGetState+0x60>)
 8000d98:	429c      	cmp	r4, r3
 8000d9a:	d105      	bne.n	8000da8 <eTaskGetState+0x38>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
 8000d9c:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8000d9e:	2b00      	cmp	r3, #0
						eReturn = eSuspended;
 8000da0:	bf14      	ite	ne
 8000da2:	2002      	movne	r0, #2
 8000da4:	2003      	moveq	r0, #3
 8000da6:	bd38      	pop	{r3, r4, r5, pc}
				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
 8000da8:	4b0a      	ldr	r3, [pc, #40]	; (8000dd4 <eTaskGetState+0x64>)
 8000daa:	429c      	cmp	r4, r3
 8000dac:	d008      	beq.n	8000dc0 <eTaskGetState+0x50>
 8000dae:	2c00      	cmp	r4, #0
				eReturn = eReady;
 8000db0:	bf0c      	ite	eq
 8000db2:	2004      	moveq	r0, #4
 8000db4:	2001      	movne	r0, #1
 8000db6:	bd38      	pop	{r3, r4, r5, pc}
			eReturn = eRunning;
 8000db8:	2000      	movs	r0, #0
 8000dba:	bd38      	pop	{r3, r4, r5, pc}
						eReturn = eBlocked;
 8000dbc:	2002      	movs	r0, #2
 8000dbe:	bd38      	pop	{r3, r4, r5, pc}
					eReturn = eDeleted;
 8000dc0:	2004      	movs	r0, #4
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 8000dc2:	bd38      	pop	{r3, r4, r5, pc}
 8000dc4:	20000048 	.word	0x20000048
 8000dc8:	2000004c 	.word	0x2000004c
 8000dcc:	20000050 	.word	0x20000050
 8000dd0:	2000011c 	.word	0x2000011c
 8000dd4:	20000130 	.word	0x20000130

08000dd8 <uxTaskPriorityGet>:
	{
 8000dd8:	b510      	push	{r4, lr}
 8000dda:	4604      	mov	r4, r0
		taskENTER_CRITICAL();
 8000ddc:	f000 ff63 	bl	8001ca6 <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTask );
 8000de0:	b90c      	cbnz	r4, 8000de6 <uxTaskPriorityGet+0xe>
 8000de2:	4b03      	ldr	r3, [pc, #12]	; (8000df0 <uxTaskPriorityGet+0x18>)
 8000de4:	681c      	ldr	r4, [r3, #0]
			uxReturn = pxTCB->uxPriority;
 8000de6:	6ae4      	ldr	r4, [r4, #44]	; 0x2c
		taskEXIT_CRITICAL();
 8000de8:	f000 ff6c 	bl	8001cc4 <vPortExitCritical>
	}
 8000dec:	4620      	mov	r0, r4
 8000dee:	bd10      	pop	{r4, pc}
 8000df0:	20000048 	.word	0x20000048

08000df4 <uxTaskPriorityGetFromISR>:

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
 8000df4:	f3ef 8311 	mrs	r3, BASEPRI
 8000df8:	f04f 02bf 	mov.w	r2, #191	; 0xbf
 8000dfc:	f382 8811 	msr	BASEPRI, r2
 8000e00:	f3bf 8f6f 	isb	sy
 8000e04:	f3bf 8f4f 	dsb	sy
			pxTCB = prvGetTCBFromHandle( xTask );
 8000e08:	b908      	cbnz	r0, 8000e0e <uxTaskPriorityGetFromISR+0x1a>
 8000e0a:	4a03      	ldr	r2, [pc, #12]	; (8000e18 <uxTaskPriorityGetFromISR+0x24>)
 8000e0c:	6810      	ldr	r0, [r2, #0]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8000e0e:	f383 8811 	msr	BASEPRI, r3
	}
 8000e12:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8000e14:	4770      	bx	lr
 8000e16:	bf00      	nop
 8000e18:	20000048 	.word	0x20000048

08000e1c <vTaskPrioritySet>:
	{
 8000e1c:	2904      	cmp	r1, #4
 8000e1e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000e22:	bf28      	it	cs
 8000e24:	2104      	movcs	r1, #4
 8000e26:	4604      	mov	r4, r0
 8000e28:	460e      	mov	r6, r1
		taskENTER_CRITICAL();
 8000e2a:	f000 ff3c 	bl	8001ca6 <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTask );
 8000e2e:	b90c      	cbnz	r4, 8000e34 <vTaskPrioritySet+0x18>
 8000e30:	4b28      	ldr	r3, [pc, #160]	; (8000ed4 <vTaskPrioritySet+0xb8>)
 8000e32:	681c      	ldr	r4, [r3, #0]
				uxCurrentBasePriority = pxTCB->uxBasePriority;
 8000e34:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
			if( uxCurrentBasePriority != uxNewPriority )
 8000e36:	42b2      	cmp	r2, r6
 8000e38:	d041      	beq.n	8000ebe <vTaskPrioritySet+0xa2>
 8000e3a:	4b26      	ldr	r3, [pc, #152]	; (8000ed4 <vTaskPrioritySet+0xb8>)
				if( uxNewPriority > uxCurrentBasePriority )
 8000e3c:	d243      	bcs.n	8000ec6 <vTaskPrioritySet+0xaa>
					if( pxTCB != pxCurrentTCB )
 8000e3e:	6819      	ldr	r1, [r3, #0]
 8000e40:	428c      	cmp	r4, r1
 8000e42:	d045      	beq.n	8000ed0 <vTaskPrioritySet+0xb4>
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 8000e44:	681b      	ldr	r3, [r3, #0]
 8000e46:	6add      	ldr	r5, [r3, #44]	; 0x2c
 8000e48:	42b5      	cmp	r5, r6
 8000e4a:	bf8c      	ite	hi
 8000e4c:	2500      	movhi	r5, #0
 8000e4e:	2501      	movls	r5, #1
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 8000e50:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8000e52:	69a3      	ldr	r3, [r4, #24]
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 8000e54:	42ba      	cmp	r2, r7
						pxTCB->uxPriority = uxNewPriority;
 8000e56:	bf08      	it	eq
 8000e58:	62e6      	streq	r6, [r4, #44]	; 0x2c
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8000e5a:	2b00      	cmp	r3, #0
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8000e5c:	f04f 0314 	mov.w	r3, #20
					pxTCB->uxBasePriority = uxNewPriority;
 8000e60:	64e6      	str	r6, [r4, #76]	; 0x4c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000e62:	bfa4      	itt	ge
 8000e64:	f1c6 0605 	rsbge	r6, r6, #5
 8000e68:	61a6      	strge	r6, [r4, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8000e6a:	4e1b      	ldr	r6, [pc, #108]	; (8000ed8 <vTaskPrioritySet+0xbc>)
 8000e6c:	6962      	ldr	r2, [r4, #20]
 8000e6e:	fb03 6307 	mla	r3, r3, r7, r6
 8000e72:	429a      	cmp	r2, r3
 8000e74:	d11a      	bne.n	8000eac <vTaskPrioritySet+0x90>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8000e76:	f104 0804 	add.w	r8, r4, #4
 8000e7a:	4640      	mov	r0, r8
 8000e7c:	f001 f891 	bl	8001fa2 <uxListRemove>
 8000e80:	b938      	cbnz	r0, 8000e92 <vTaskPrioritySet+0x76>
						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
 8000e82:	2201      	movs	r2, #1
 8000e84:	4915      	ldr	r1, [pc, #84]	; (8000edc <vTaskPrioritySet+0xc0>)
 8000e86:	fa02 f707 	lsl.w	r7, r2, r7
 8000e8a:	680b      	ldr	r3, [r1, #0]
 8000e8c:	ea23 0707 	bic.w	r7, r3, r7
 8000e90:	600f      	str	r7, [r1, #0]
					prvAddTaskToReadyList( pxTCB );
 8000e92:	2301      	movs	r3, #1
 8000e94:	4911      	ldr	r1, [pc, #68]	; (8000edc <vTaskPrioritySet+0xc0>)
 8000e96:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000e98:	6808      	ldr	r0, [r1, #0]
 8000e9a:	4093      	lsls	r3, r2
 8000e9c:	4303      	orrs	r3, r0
 8000e9e:	2014      	movs	r0, #20
 8000ea0:	600b      	str	r3, [r1, #0]
 8000ea2:	fb00 6002 	mla	r0, r0, r2, r6
 8000ea6:	4641      	mov	r1, r8
 8000ea8:	f001 f858 	bl	8001f5c <vListInsertEnd>
				if( xYieldRequired != pdFALSE )
 8000eac:	b13d      	cbz	r5, 8000ebe <vTaskPrioritySet+0xa2>
					taskYIELD_IF_USING_PREEMPTION();
 8000eae:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000eb2:	4b0b      	ldr	r3, [pc, #44]	; (8000ee0 <vTaskPrioritySet+0xc4>)
 8000eb4:	601a      	str	r2, [r3, #0]
 8000eb6:	f3bf 8f4f 	dsb	sy
 8000eba:	f3bf 8f6f 	isb	sy
	}
 8000ebe:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		taskEXIT_CRITICAL();
 8000ec2:	f000 beff 	b.w	8001cc4 <vPortExitCritical>
				else if( pxTCB == pxCurrentTCB )
 8000ec6:	681d      	ldr	r5, [r3, #0]
 8000ec8:	1b63      	subs	r3, r4, r5
 8000eca:	425d      	negs	r5, r3
 8000ecc:	415d      	adcs	r5, r3
 8000ece:	e7bf      	b.n	8000e50 <vTaskPrioritySet+0x34>
	BaseType_t xYieldRequired = pdFALSE;
 8000ed0:	2500      	movs	r5, #0
 8000ed2:	e7bd      	b.n	8000e50 <vTaskPrioritySet+0x34>
 8000ed4:	20000048 	.word	0x20000048
 8000ed8:	20000054 	.word	0x20000054
 8000edc:	200000cc 	.word	0x200000cc
 8000ee0:	e000ed04 	.word	0xe000ed04

08000ee4 <vTaskResume>:
	{
 8000ee4:	b570      	push	{r4, r5, r6, lr}
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 8000ee6:	4604      	mov	r4, r0
 8000ee8:	b360      	cbz	r0, 8000f44 <vTaskResume+0x60>
 8000eea:	4d17      	ldr	r5, [pc, #92]	; (8000f48 <vTaskResume+0x64>)
 8000eec:	682b      	ldr	r3, [r5, #0]
 8000eee:	4298      	cmp	r0, r3
 8000ef0:	d028      	beq.n	8000f44 <vTaskResume+0x60>
			taskENTER_CRITICAL();
 8000ef2:	f000 fed8 	bl	8001ca6 <vPortEnterCritical>
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 8000ef6:	4620      	mov	r0, r4
 8000ef8:	f7ff fd8a 	bl	8000a10 <prvTaskIsTaskSuspended>
 8000efc:	b1f0      	cbz	r0, 8000f3c <vTaskResume+0x58>
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
 8000efe:	1d26      	adds	r6, r4, #4
 8000f00:	4630      	mov	r0, r6
 8000f02:	f001 f84e 	bl	8001fa2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8000f06:	2301      	movs	r3, #1
 8000f08:	4910      	ldr	r1, [pc, #64]	; (8000f4c <vTaskResume+0x68>)
 8000f0a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000f0c:	6808      	ldr	r0, [r1, #0]
 8000f0e:	4093      	lsls	r3, r2
 8000f10:	4303      	orrs	r3, r0
 8000f12:	2014      	movs	r0, #20
 8000f14:	600b      	str	r3, [r1, #0]
 8000f16:	4b0e      	ldr	r3, [pc, #56]	; (8000f50 <vTaskResume+0x6c>)
 8000f18:	4631      	mov	r1, r6
 8000f1a:	fb00 3002 	mla	r0, r0, r2, r3
 8000f1e:	f001 f81d 	bl	8001f5c <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8000f22:	682b      	ldr	r3, [r5, #0]
 8000f24:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000f26:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000f28:	429a      	cmp	r2, r3
 8000f2a:	d307      	bcc.n	8000f3c <vTaskResume+0x58>
						taskYIELD_IF_USING_PREEMPTION();
 8000f2c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000f30:	4b08      	ldr	r3, [pc, #32]	; (8000f54 <vTaskResume+0x70>)
 8000f32:	601a      	str	r2, [r3, #0]
 8000f34:	f3bf 8f4f 	dsb	sy
 8000f38:	f3bf 8f6f 	isb	sy
	}
 8000f3c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			taskEXIT_CRITICAL();
 8000f40:	f000 bec0 	b.w	8001cc4 <vPortExitCritical>
 8000f44:	bd70      	pop	{r4, r5, r6, pc}
 8000f46:	bf00      	nop
 8000f48:	20000048 	.word	0x20000048
 8000f4c:	200000cc 	.word	0x200000cc
 8000f50:	20000054 	.word	0x20000054
 8000f54:	e000ed04 	.word	0xe000ed04

08000f58 <xTaskResumeFromISR>:
	{
 8000f58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000f5a:	4605      	mov	r5, r0
	__asm volatile
 8000f5c:	f3ef 8611 	mrs	r6, BASEPRI
 8000f60:	f04f 03bf 	mov.w	r3, #191	; 0xbf
 8000f64:	f383 8811 	msr	BASEPRI, r3
 8000f68:	f3bf 8f6f 	isb	sy
 8000f6c:	f3bf 8f4f 	dsb	sy
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 8000f70:	f7ff fd4e 	bl	8000a10 <prvTaskIsTaskSuspended>
 8000f74:	b338      	cbz	r0, 8000fc6 <xTaskResumeFromISR+0x6e>
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8000f76:	4b15      	ldr	r3, [pc, #84]	; (8000fcc <xTaskResumeFromISR+0x74>)
 8000f78:	681b      	ldr	r3, [r3, #0]
 8000f7a:	b9eb      	cbnz	r3, 8000fb8 <xTaskResumeFromISR+0x60>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8000f7c:	4b14      	ldr	r3, [pc, #80]	; (8000fd0 <xTaskResumeFromISR+0x78>)
 8000f7e:	6aec      	ldr	r4, [r5, #44]	; 0x2c
 8000f80:	681b      	ldr	r3, [r3, #0]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8000f82:	1d2f      	adds	r7, r5, #4
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8000f84:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8000f86:	4284      	cmp	r4, r0
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8000f88:	4638      	mov	r0, r7
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8000f8a:	bf34      	ite	cc
 8000f8c:	2400      	movcc	r4, #0
 8000f8e:	2401      	movcs	r4, #1
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8000f90:	f001 f807 	bl	8001fa2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8000f94:	2301      	movs	r3, #1
 8000f96:	490f      	ldr	r1, [pc, #60]	; (8000fd4 <xTaskResumeFromISR+0x7c>)
 8000f98:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8000f9a:	6808      	ldr	r0, [r1, #0]
 8000f9c:	4093      	lsls	r3, r2
 8000f9e:	4303      	orrs	r3, r0
 8000fa0:	2014      	movs	r0, #20
 8000fa2:	600b      	str	r3, [r1, #0]
 8000fa4:	4b0c      	ldr	r3, [pc, #48]	; (8000fd8 <xTaskResumeFromISR+0x80>)
 8000fa6:	4639      	mov	r1, r7
 8000fa8:	fb00 3002 	mla	r0, r0, r2, r3
 8000fac:	f000 ffd6 	bl	8001f5c <vListInsertEnd>
	__asm volatile
 8000fb0:	f386 8811 	msr	BASEPRI, r6
	}
 8000fb4:	4620      	mov	r0, r4
 8000fb6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 8000fb8:	f105 0118 	add.w	r1, r5, #24
 8000fbc:	4807      	ldr	r0, [pc, #28]	; (8000fdc <xTaskResumeFromISR+0x84>)
 8000fbe:	f000 ffcd 	bl	8001f5c <vListInsertEnd>
	BaseType_t xYieldRequired = pdFALSE;
 8000fc2:	2400      	movs	r4, #0
 8000fc4:	e7f4      	b.n	8000fb0 <xTaskResumeFromISR+0x58>
 8000fc6:	4604      	mov	r4, r0
 8000fc8:	e7f2      	b.n	8000fb0 <xTaskResumeFromISR+0x58>
 8000fca:	bf00      	nop
 8000fcc:	200000c4 	.word	0x200000c4
 8000fd0:	20000048 	.word	0x20000048
 8000fd4:	200000cc 	.word	0x200000cc
 8000fd8:	20000054 	.word	0x20000054
 8000fdc:	20000104 	.word	0x20000104

08000fe0 <vTaskStartScheduler>:
{
 8000fe0:	b513      	push	{r0, r1, r4, lr}
		xReturn = xTaskCreate(	prvIdleTask,
 8000fe2:	2400      	movs	r4, #0
 8000fe4:	4b10      	ldr	r3, [pc, #64]	; (8001028 <vTaskStartScheduler+0x48>)
 8000fe6:	9400      	str	r4, [sp, #0]
 8000fe8:	9301      	str	r3, [sp, #4]
 8000fea:	2278      	movs	r2, #120	; 0x78
 8000fec:	4623      	mov	r3, r4
 8000fee:	490f      	ldr	r1, [pc, #60]	; (800102c <vTaskStartScheduler+0x4c>)
 8000ff0:	480f      	ldr	r0, [pc, #60]	; (8001030 <vTaskStartScheduler+0x50>)
 8000ff2:	f7ff fd77 	bl	8000ae4 <xTaskCreate>
	if( xReturn == pdPASS )
 8000ff6:	2801      	cmp	r0, #1
 8000ff8:	d114      	bne.n	8001024 <vTaskStartScheduler+0x44>
	__asm volatile
 8000ffa:	f04f 03bf 	mov.w	r3, #191	; 0xbf
 8000ffe:	f383 8811 	msr	BASEPRI, r3
 8001002:	f3bf 8f6f 	isb	sy
 8001006:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 800100a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800100e:	4b09      	ldr	r3, [pc, #36]	; (8001034 <vTaskStartScheduler+0x54>)
 8001010:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 8001012:	4b09      	ldr	r3, [pc, #36]	; (8001038 <vTaskStartScheduler+0x58>)
 8001014:	6018      	str	r0, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 8001016:	4b09      	ldr	r3, [pc, #36]	; (800103c <vTaskStartScheduler+0x5c>)
 8001018:	601c      	str	r4, [r3, #0]
}
 800101a:	b002      	add	sp, #8
 800101c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		if( xPortStartScheduler() != pdFALSE )
 8001020:	f000 bea2 	b.w	8001d68 <xPortStartScheduler>
}
 8001024:	b002      	add	sp, #8
 8001026:	bd10      	pop	{r4, pc}
 8001028:	200000f8 	.word	0x200000f8
 800102c:	08002082 	.word	0x08002082
 8001030:	08001311 	.word	0x08001311
 8001034:	200000fc 	.word	0x200000fc
 8001038:	20000118 	.word	0x20000118
 800103c:	20000144 	.word	0x20000144

08001040 <vTaskEndScheduler>:
 8001040:	f04f 03bf 	mov.w	r3, #191	; 0xbf
 8001044:	f383 8811 	msr	BASEPRI, r3
 8001048:	f3bf 8f6f 	isb	sy
 800104c:	f3bf 8f4f 	dsb	sy
	xSchedulerRunning = pdFALSE;
 8001050:	2200      	movs	r2, #0
 8001052:	4b02      	ldr	r3, [pc, #8]	; (800105c <vTaskEndScheduler+0x1c>)
 8001054:	601a      	str	r2, [r3, #0]
	vPortEndScheduler();
 8001056:	f000 be25 	b.w	8001ca4 <vPortEndScheduler>
 800105a:	bf00      	nop
 800105c:	20000118 	.word	0x20000118

08001060 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 8001060:	4a02      	ldr	r2, [pc, #8]	; (800106c <vTaskSuspendAll+0xc>)
 8001062:	6813      	ldr	r3, [r2, #0]
 8001064:	3301      	adds	r3, #1
 8001066:	6013      	str	r3, [r2, #0]
 8001068:	4770      	bx	lr
 800106a:	bf00      	nop
 800106c:	200000c4 	.word	0x200000c4

08001070 <xTaskGetTickCount>:
 8001070:	4b01      	ldr	r3, [pc, #4]	; (8001078 <xTaskGetTickCount+0x8>)
 8001072:	6818      	ldr	r0, [r3, #0]
 8001074:	4770      	bx	lr
 8001076:	bf00      	nop
 8001078:	20000144 	.word	0x20000144

0800107c <xTaskGetTickCountFromISR>:
		xReturn = xTickCount;
 800107c:	4b01      	ldr	r3, [pc, #4]	; (8001084 <xTaskGetTickCountFromISR+0x8>)
 800107e:	6818      	ldr	r0, [r3, #0]
}
 8001080:	4770      	bx	lr
 8001082:	bf00      	nop
 8001084:	20000144 	.word	0x20000144

08001088 <uxTaskGetNumberOfTasks>:
	return uxCurrentNumberOfTasks;
 8001088:	4b01      	ldr	r3, [pc, #4]	; (8001090 <uxTaskGetNumberOfTasks+0x8>)
 800108a:	6818      	ldr	r0, [r3, #0]
}
 800108c:	4770      	bx	lr
 800108e:	bf00      	nop
 8001090:	200000b8 	.word	0x200000b8

08001094 <pcTaskGetName>:
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 8001094:	b908      	cbnz	r0, 800109a <pcTaskGetName+0x6>
 8001096:	4b02      	ldr	r3, [pc, #8]	; (80010a0 <pcTaskGetName+0xc>)
 8001098:	6818      	ldr	r0, [r3, #0]
}
 800109a:	3034      	adds	r0, #52	; 0x34
 800109c:	4770      	bx	lr
 800109e:	bf00      	nop
 80010a0:	20000048 	.word	0x20000048

080010a4 <xTaskIncrementTick>:
{
 80010a4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80010a8:	4b36      	ldr	r3, [pc, #216]	; (8001184 <xTaskIncrementTick+0xe0>)
 80010aa:	681b      	ldr	r3, [r3, #0]
 80010ac:	2b00      	cmp	r3, #0
 80010ae:	d147      	bne.n	8001140 <xTaskIncrementTick+0x9c>
		const TickType_t xConstTickCount = xTickCount + 1;
 80010b0:	4b35      	ldr	r3, [pc, #212]	; (8001188 <xTaskIncrementTick+0xe4>)
 80010b2:	681c      	ldr	r4, [r3, #0]
 80010b4:	3401      	adds	r4, #1
		xTickCount = xConstTickCount;
 80010b6:	601c      	str	r4, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U )
 80010b8:	b95c      	cbnz	r4, 80010d2 <xTaskIncrementTick+0x2e>
			taskSWITCH_DELAYED_LISTS();
 80010ba:	4a34      	ldr	r2, [pc, #208]	; (800118c <xTaskIncrementTick+0xe8>)
 80010bc:	4b34      	ldr	r3, [pc, #208]	; (8001190 <xTaskIncrementTick+0xec>)
 80010be:	6811      	ldr	r1, [r2, #0]
 80010c0:	6818      	ldr	r0, [r3, #0]
 80010c2:	6010      	str	r0, [r2, #0]
 80010c4:	4a33      	ldr	r2, [pc, #204]	; (8001194 <xTaskIncrementTick+0xf0>)
 80010c6:	6019      	str	r1, [r3, #0]
 80010c8:	6813      	ldr	r3, [r2, #0]
 80010ca:	3301      	adds	r3, #1
 80010cc:	6013      	str	r3, [r2, #0]
 80010ce:	f7ff fcb1 	bl	8000a34 <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 80010d2:	4d31      	ldr	r5, [pc, #196]	; (8001198 <xTaskIncrementTick+0xf4>)
 80010d4:	f04f 0b00 	mov.w	fp, #0
 80010d8:	682b      	ldr	r3, [r5, #0]
 80010da:	4f30      	ldr	r7, [pc, #192]	; (800119c <xTaskIncrementTick+0xf8>)
 80010dc:	429c      	cmp	r4, r3
 80010de:	d33e      	bcc.n	800115e <xTaskIncrementTick+0xba>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80010e0:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 800118c <xTaskIncrementTick+0xe8>
					prvAddTaskToReadyList( pxTCB );
 80010e4:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 80011ac <xTaskIncrementTick+0x108>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80010e8:	f8d8 2000 	ldr.w	r2, [r8]
 80010ec:	6812      	ldr	r2, [r2, #0]
 80010ee:	bb72      	cbnz	r2, 800114e <xTaskIncrementTick+0xaa>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80010f0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80010f4:	602a      	str	r2, [r5, #0]
					break;
 80010f6:	e032      	b.n	800115e <xTaskIncrementTick+0xba>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80010f8:	f106 0a04 	add.w	sl, r6, #4
 80010fc:	4650      	mov	r0, sl
 80010fe:	f000 ff50 	bl	8001fa2 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8001102:	6ab1      	ldr	r1, [r6, #40]	; 0x28
 8001104:	b119      	cbz	r1, 800110e <xTaskIncrementTick+0x6a>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8001106:	f106 0018 	add.w	r0, r6, #24
 800110a:	f000 ff4a 	bl	8001fa2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800110e:	2201      	movs	r2, #1
 8001110:	f04f 0e14 	mov.w	lr, #20
 8001114:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 8001116:	f8d9 3000 	ldr.w	r3, [r9]
 800111a:	fa02 f100 	lsl.w	r1, r2, r0
 800111e:	4319      	orrs	r1, r3
 8001120:	4b1f      	ldr	r3, [pc, #124]	; (80011a0 <xTaskIncrementTick+0xfc>)
 8001122:	f8c9 1000 	str.w	r1, [r9]
 8001126:	fb0e 3000 	mla	r0, lr, r0, r3
 800112a:	4651      	mov	r1, sl
 800112c:	f000 ff16 	bl	8001f5c <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8001130:	6838      	ldr	r0, [r7, #0]
 8001132:	6af1      	ldr	r1, [r6, #44]	; 0x2c
 8001134:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
 8001136:	4291      	cmp	r1, r2
 8001138:	bf28      	it	cs
 800113a:	f04f 0b01 	movcs.w	fp, #1
 800113e:	e7d3      	b.n	80010e8 <xTaskIncrementTick+0x44>
		++uxPendedTicks;
 8001140:	4a18      	ldr	r2, [pc, #96]	; (80011a4 <xTaskIncrementTick+0x100>)
BaseType_t xSwitchRequired = pdFALSE;
 8001142:	f04f 0b00 	mov.w	fp, #0
		++uxPendedTicks;
 8001146:	6813      	ldr	r3, [r2, #0]
 8001148:	3301      	adds	r3, #1
 800114a:	6013      	str	r3, [r2, #0]
 800114c:	e011      	b.n	8001172 <xTaskIncrementTick+0xce>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800114e:	f8d8 2000 	ldr.w	r2, [r8]
 8001152:	68d2      	ldr	r2, [r2, #12]
 8001154:	68d6      	ldr	r6, [r2, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8001156:	6871      	ldr	r1, [r6, #4]
					if( xConstTickCount < xItemValue )
 8001158:	428c      	cmp	r4, r1
 800115a:	d2cd      	bcs.n	80010f8 <xTaskIncrementTick+0x54>
						xNextTaskUnblockTime = xItemValue;
 800115c:	6029      	str	r1, [r5, #0]
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 800115e:	683a      	ldr	r2, [r7, #0]
 8001160:	4b0f      	ldr	r3, [pc, #60]	; (80011a0 <xTaskIncrementTick+0xfc>)
 8001162:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 8001164:	2214      	movs	r2, #20
 8001166:	434a      	muls	r2, r1
 8001168:	589a      	ldr	r2, [r3, r2]
				xSwitchRequired = pdTRUE;
 800116a:	2a02      	cmp	r2, #2
 800116c:	bf28      	it	cs
 800116e:	f04f 0b01 	movcs.w	fp, #1
		if( xYieldPending != pdFALSE )
 8001172:	4a0d      	ldr	r2, [pc, #52]	; (80011a8 <xTaskIncrementTick+0x104>)
 8001174:	6812      	ldr	r2, [r2, #0]
			xSwitchRequired = pdTRUE;
 8001176:	2a00      	cmp	r2, #0
 8001178:	bf18      	it	ne
 800117a:	f04f 0b01 	movne.w	fp, #1
}
 800117e:	4658      	mov	r0, fp
 8001180:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001184:	200000c4 	.word	0x200000c4
 8001188:	20000144 	.word	0x20000144
 800118c:	2000004c 	.word	0x2000004c
 8001190:	20000050 	.word	0x20000050
 8001194:	20000100 	.word	0x20000100
 8001198:	200000fc 	.word	0x200000fc
 800119c:	20000048 	.word	0x20000048
 80011a0:	20000054 	.word	0x20000054
 80011a4:	200000c0 	.word	0x200000c0
 80011a8:	20000148 	.word	0x20000148
 80011ac:	200000cc 	.word	0x200000cc

080011b0 <xTaskResumeAll>:
{
 80011b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	taskENTER_CRITICAL();
 80011b4:	f000 fd77 	bl	8001ca6 <vPortEnterCritical>
		--uxSchedulerSuspended;
 80011b8:	4b2a      	ldr	r3, [pc, #168]	; (8001264 <xTaskResumeAll+0xb4>)
 80011ba:	681a      	ldr	r2, [r3, #0]
 80011bc:	3a01      	subs	r2, #1
 80011be:	601a      	str	r2, [r3, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80011c0:	681c      	ldr	r4, [r3, #0]
 80011c2:	b12c      	cbz	r4, 80011d0 <xTaskResumeAll+0x20>
BaseType_t xAlreadyYielded = pdFALSE;
 80011c4:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 80011c6:	f000 fd7d 	bl	8001cc4 <vPortExitCritical>
}
 80011ca:	4620      	mov	r0, r4
 80011cc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 80011d0:	4b25      	ldr	r3, [pc, #148]	; (8001268 <xTaskResumeAll+0xb8>)
 80011d2:	681b      	ldr	r3, [r3, #0]
 80011d4:	2b00      	cmp	r3, #0
 80011d6:	d0f5      	beq.n	80011c4 <xTaskResumeAll+0x14>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80011d8:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 8001280 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyList( pxTCB );
 80011dc:	4f23      	ldr	r7, [pc, #140]	; (800126c <xTaskResumeAll+0xbc>)
 80011de:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 8001284 <xTaskResumeAll+0xd4>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80011e2:	f8d9 3000 	ldr.w	r3, [r9]
 80011e6:	b9e3      	cbnz	r3, 8001222 <xTaskResumeAll+0x72>
				if( pxTCB != NULL )
 80011e8:	b10c      	cbz	r4, 80011ee <xTaskResumeAll+0x3e>
					prvResetNextTaskUnblockTime();
 80011ea:	f7ff fc23 	bl	8000a34 <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 80011ee:	4d20      	ldr	r5, [pc, #128]	; (8001270 <xTaskResumeAll+0xc0>)
 80011f0:	682c      	ldr	r4, [r5, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 80011f2:	b144      	cbz	r4, 8001206 <xTaskResumeAll+0x56>
								xYieldPending = pdTRUE;
 80011f4:	2701      	movs	r7, #1
 80011f6:	4e1f      	ldr	r6, [pc, #124]	; (8001274 <xTaskResumeAll+0xc4>)
							if( xTaskIncrementTick() != pdFALSE )
 80011f8:	f7ff ff54 	bl	80010a4 <xTaskIncrementTick>
 80011fc:	b100      	cbz	r0, 8001200 <xTaskResumeAll+0x50>
								xYieldPending = pdTRUE;
 80011fe:	6037      	str	r7, [r6, #0]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 8001200:	3c01      	subs	r4, #1
 8001202:	d1f9      	bne.n	80011f8 <xTaskResumeAll+0x48>
						uxPendedTicks = 0;
 8001204:	602c      	str	r4, [r5, #0]
				if( xYieldPending != pdFALSE )
 8001206:	4b1b      	ldr	r3, [pc, #108]	; (8001274 <xTaskResumeAll+0xc4>)
 8001208:	681b      	ldr	r3, [r3, #0]
 800120a:	2b00      	cmp	r3, #0
 800120c:	d0da      	beq.n	80011c4 <xTaskResumeAll+0x14>
					taskYIELD_IF_USING_PREEMPTION();
 800120e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001212:	4b19      	ldr	r3, [pc, #100]	; (8001278 <xTaskResumeAll+0xc8>)
 8001214:	601a      	str	r2, [r3, #0]
 8001216:	f3bf 8f4f 	dsb	sy
 800121a:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 800121e:	2401      	movs	r4, #1
 8001220:	e7d1      	b.n	80011c6 <xTaskResumeAll+0x16>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8001222:	f8d9 300c 	ldr.w	r3, [r9, #12]
					prvAddTaskToReadyList( pxTCB );
 8001226:	2501      	movs	r5, #1
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8001228:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800122a:	1d26      	adds	r6, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800122c:	f104 0018 	add.w	r0, r4, #24
 8001230:	f000 feb7 	bl	8001fa2 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8001234:	4630      	mov	r0, r6
 8001236:	f000 feb4 	bl	8001fa2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800123a:	2014      	movs	r0, #20
 800123c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800123e:	6839      	ldr	r1, [r7, #0]
 8001240:	fa05 f302 	lsl.w	r3, r5, r2
 8001244:	430b      	orrs	r3, r1
 8001246:	fb00 8002 	mla	r0, r0, r2, r8
 800124a:	4631      	mov	r1, r6
 800124c:	603b      	str	r3, [r7, #0]
 800124e:	f000 fe85 	bl	8001f5c <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8001252:	4b0a      	ldr	r3, [pc, #40]	; (800127c <xTaskResumeAll+0xcc>)
 8001254:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001256:	681b      	ldr	r3, [r3, #0]
 8001258:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800125a:	429a      	cmp	r2, r3
						xYieldPending = pdTRUE;
 800125c:	bf24      	itt	cs
 800125e:	4b05      	ldrcs	r3, [pc, #20]	; (8001274 <xTaskResumeAll+0xc4>)
 8001260:	601d      	strcs	r5, [r3, #0]
 8001262:	e7be      	b.n	80011e2 <xTaskResumeAll+0x32>
 8001264:	200000c4 	.word	0x200000c4
 8001268:	200000b8 	.word	0x200000b8
 800126c:	200000cc 	.word	0x200000cc
 8001270:	200000c0 	.word	0x200000c0
 8001274:	20000148 	.word	0x20000148
 8001278:	e000ed04 	.word	0xe000ed04
 800127c:	20000048 	.word	0x20000048
 8001280:	20000104 	.word	0x20000104
 8001284:	20000054 	.word	0x20000054

08001288 <vTaskDelayUntil>:
	{
 8001288:	b510      	push	{r4, lr}
		vTaskSuspendAll();
 800128a:	f7ff fee9 	bl	8001060 <vTaskSuspendAll>
			const TickType_t xConstTickCount = xTickCount;
 800128e:	4b12      	ldr	r3, [pc, #72]	; (80012d8 <vTaskDelayUntil+0x50>)
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8001290:	6804      	ldr	r4, [r0, #0]
			const TickType_t xConstTickCount = xTickCount;
 8001292:	681a      	ldr	r2, [r3, #0]
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8001294:	1863      	adds	r3, r4, r1
			if( xConstTickCount < *pxPreviousWakeTime )
 8001296:	42a2      	cmp	r2, r4
 8001298:	d217      	bcs.n	80012ca <vTaskDelayUntil+0x42>
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 800129a:	429c      	cmp	r4, r3
 800129c:	d919      	bls.n	80012d2 <vTaskDelayUntil+0x4a>
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 800129e:	429a      	cmp	r2, r3
 80012a0:	bf2c      	ite	cs
 80012a2:	2100      	movcs	r1, #0
 80012a4:	2101      	movcc	r1, #1
			*pxPreviousWakeTime = xTimeToWake;
 80012a6:	6003      	str	r3, [r0, #0]
			if( xShouldDelay != pdFALSE )
 80012a8:	b119      	cbz	r1, 80012b2 <vTaskDelayUntil+0x2a>
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 80012aa:	2100      	movs	r1, #0
 80012ac:	1a98      	subs	r0, r3, r2
 80012ae:	f7ff fbd3 	bl	8000a58 <prvAddCurrentTaskToDelayedList>
		xAlreadyYielded = xTaskResumeAll();
 80012b2:	f7ff ff7d 	bl	80011b0 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 80012b6:	b938      	cbnz	r0, 80012c8 <vTaskDelayUntil+0x40>
			portYIELD_WITHIN_API();
 80012b8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80012bc:	4b07      	ldr	r3, [pc, #28]	; (80012dc <vTaskDelayUntil+0x54>)
 80012be:	601a      	str	r2, [r3, #0]
 80012c0:	f3bf 8f4f 	dsb	sy
 80012c4:	f3bf 8f6f 	isb	sy
 80012c8:	bd10      	pop	{r4, pc}
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 80012ca:	429c      	cmp	r4, r3
 80012cc:	d9e7      	bls.n	800129e <vTaskDelayUntil+0x16>
					xShouldDelay = pdTRUE;
 80012ce:	2101      	movs	r1, #1
 80012d0:	e7e9      	b.n	80012a6 <vTaskDelayUntil+0x1e>
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 80012d2:	2100      	movs	r1, #0
 80012d4:	e7e7      	b.n	80012a6 <vTaskDelayUntil+0x1e>
 80012d6:	bf00      	nop
 80012d8:	20000144 	.word	0x20000144
 80012dc:	e000ed04 	.word	0xe000ed04

080012e0 <vTaskDelay>:
	{
 80012e0:	b508      	push	{r3, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 80012e2:	b940      	cbnz	r0, 80012f6 <vTaskDelay+0x16>
			portYIELD_WITHIN_API();
 80012e4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80012e8:	4b08      	ldr	r3, [pc, #32]	; (800130c <vTaskDelay+0x2c>)
 80012ea:	601a      	str	r2, [r3, #0]
 80012ec:	f3bf 8f4f 	dsb	sy
 80012f0:	f3bf 8f6f 	isb	sy
 80012f4:	bd08      	pop	{r3, pc}
			vTaskSuspendAll();
 80012f6:	f7ff feb3 	bl	8001060 <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 80012fa:	2100      	movs	r1, #0
 80012fc:	f7ff fbac 	bl	8000a58 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 8001300:	f7ff ff56 	bl	80011b0 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 8001304:	2800      	cmp	r0, #0
 8001306:	d0ed      	beq.n	80012e4 <vTaskDelay+0x4>
 8001308:	bd08      	pop	{r3, pc}
 800130a:	bf00      	nop
 800130c:	e000ed04 	.word	0xe000ed04

08001310 <prvIdleTask>:
{
 8001310:	b508      	push	{r3, lr}
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8001312:	4e17      	ldr	r6, [pc, #92]	; (8001370 <prvIdleTask+0x60>)
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8001314:	4c17      	ldr	r4, [pc, #92]	; (8001374 <prvIdleTask+0x64>)
 8001316:	6823      	ldr	r3, [r4, #0]
 8001318:	b963      	cbnz	r3, 8001334 <prvIdleTask+0x24>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 800131a:	4b17      	ldr	r3, [pc, #92]	; (8001378 <prvIdleTask+0x68>)
 800131c:	681b      	ldr	r3, [r3, #0]
 800131e:	2b01      	cmp	r3, #1
 8001320:	d9f8      	bls.n	8001314 <prvIdleTask+0x4>
				taskYIELD();
 8001322:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001326:	4b15      	ldr	r3, [pc, #84]	; (800137c <prvIdleTask+0x6c>)
 8001328:	601a      	str	r2, [r3, #0]
 800132a:	f3bf 8f4f 	dsb	sy
 800132e:	f3bf 8f6f 	isb	sy
 8001332:	e7ef      	b.n	8001314 <prvIdleTask+0x4>
			vTaskSuspendAll();
 8001334:	f7ff fe94 	bl	8001060 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8001338:	6835      	ldr	r5, [r6, #0]
			( void ) xTaskResumeAll();
 800133a:	f7ff ff39 	bl	80011b0 <xTaskResumeAll>
			if( xListIsEmpty == pdFALSE )
 800133e:	2d00      	cmp	r5, #0
 8001340:	d0e9      	beq.n	8001316 <prvIdleTask+0x6>
				taskENTER_CRITICAL();
 8001342:	f000 fcb0 	bl	8001ca6 <vPortEnterCritical>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 8001346:	68f3      	ldr	r3, [r6, #12]
 8001348:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800134a:	1d28      	adds	r0, r5, #4
 800134c:	f000 fe29 	bl	8001fa2 <uxListRemove>
					--uxCurrentNumberOfTasks;
 8001350:	4a0b      	ldr	r2, [pc, #44]	; (8001380 <prvIdleTask+0x70>)
 8001352:	6813      	ldr	r3, [r2, #0]
 8001354:	3b01      	subs	r3, #1
 8001356:	6013      	str	r3, [r2, #0]
					--uxDeletedTasksWaitingCleanUp;
 8001358:	6823      	ldr	r3, [r4, #0]
 800135a:	3b01      	subs	r3, #1
 800135c:	6023      	str	r3, [r4, #0]
				taskEXIT_CRITICAL();
 800135e:	f000 fcb1 	bl	8001cc4 <vPortExitCritical>
			vPortFree( pxTCB->pxStack );
 8001362:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8001364:	f000 fdb8 	bl	8001ed8 <vPortFree>
			vPortFree( pxTCB );
 8001368:	4628      	mov	r0, r5
 800136a:	f000 fdb5 	bl	8001ed8 <vPortFree>
 800136e:	e7d2      	b.n	8001316 <prvIdleTask+0x6>
 8001370:	20000130 	.word	0x20000130
 8001374:	200000bc 	.word	0x200000bc
 8001378:	20000054 	.word	0x20000054
 800137c:	e000ed04 	.word	0xe000ed04
 8001380:	200000b8 	.word	0x200000b8

08001384 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8001384:	4b1e      	ldr	r3, [pc, #120]	; (8001400 <vTaskSwitchContext+0x7c>)
{
 8001386:	b570      	push	{r4, r5, r6, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8001388:	681a      	ldr	r2, [r3, #0]
 800138a:	4b1e      	ldr	r3, [pc, #120]	; (8001404 <vTaskSwitchContext+0x80>)
 800138c:	b112      	cbz	r2, 8001394 <vTaskSwitchContext+0x10>
		xYieldPending = pdTRUE;
 800138e:	2201      	movs	r2, #1
 8001390:	601a      	str	r2, [r3, #0]
 8001392:	bd70      	pop	{r4, r5, r6, pc}
		taskCHECK_FOR_STACK_OVERFLOW();
 8001394:	4c1c      	ldr	r4, [pc, #112]	; (8001408 <vTaskSwitchContext+0x84>)
		xYieldPending = pdFALSE;
 8001396:	601a      	str	r2, [r3, #0]
		taskCHECK_FOR_STACK_OVERFLOW();
 8001398:	6823      	ldr	r3, [r4, #0]
 800139a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800139c:	681a      	ldr	r2, [r3, #0]
 800139e:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 80013a2:	d10b      	bne.n	80013bc <vTaskSwitchContext+0x38>
 80013a4:	685a      	ldr	r2, [r3, #4]
 80013a6:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 80013aa:	d107      	bne.n	80013bc <vTaskSwitchContext+0x38>
 80013ac:	689a      	ldr	r2, [r3, #8]
 80013ae:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 80013b2:	d103      	bne.n	80013bc <vTaskSwitchContext+0x38>
 80013b4:	68db      	ldr	r3, [r3, #12]
 80013b6:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
 80013ba:	d004      	beq.n	80013c6 <vTaskSwitchContext+0x42>
 80013bc:	6820      	ldr	r0, [r4, #0]
 80013be:	6821      	ldr	r1, [r4, #0]
 80013c0:	3134      	adds	r1, #52	; 0x34
 80013c2:	f7fe ff05 	bl	80001d0 <vApplicationStackOverflowHook>
		taskSELECT_HIGHEST_PRIORITY_TASK();
 80013c6:	4b11      	ldr	r3, [pc, #68]	; (800140c <vTaskSwitchContext+0x88>)
 80013c8:	681b      	ldr	r3, [r3, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 80013ca:	fab3 f383 	clz	r3, r3
 80013ce:	2014      	movs	r0, #20
 80013d0:	b2db      	uxtb	r3, r3
 80013d2:	f1c3 031f 	rsb	r3, r3, #31
 80013d6:	fb00 f203 	mul.w	r2, r0, r3
 80013da:	490d      	ldr	r1, [pc, #52]	; (8001410 <vTaskSwitchContext+0x8c>)
 80013dc:	188d      	adds	r5, r1, r2
 80013de:	686e      	ldr	r6, [r5, #4]
 80013e0:	3208      	adds	r2, #8
 80013e2:	6876      	ldr	r6, [r6, #4]
 80013e4:	440a      	add	r2, r1
 80013e6:	4296      	cmp	r6, r2
 80013e8:	fb00 1303 	mla	r3, r0, r3, r1
 80013ec:	bf08      	it	eq
 80013ee:	6872      	ldreq	r2, [r6, #4]
 80013f0:	606e      	str	r6, [r5, #4]
 80013f2:	bf08      	it	eq
 80013f4:	606a      	streq	r2, [r5, #4]
 80013f6:	685b      	ldr	r3, [r3, #4]
 80013f8:	68db      	ldr	r3, [r3, #12]
 80013fa:	6023      	str	r3, [r4, #0]
 80013fc:	bd70      	pop	{r4, r5, r6, pc}
 80013fe:	bf00      	nop
 8001400:	200000c4 	.word	0x200000c4
 8001404:	20000148 	.word	0x20000148
 8001408:	20000048 	.word	0x20000048
 800140c:	200000cc 	.word	0x200000cc
 8001410:	20000054 	.word	0x20000054

08001414 <vTaskSuspend>:
	{
 8001414:	b570      	push	{r4, r5, r6, lr}
 8001416:	4604      	mov	r4, r0
 8001418:	4e23      	ldr	r6, [pc, #140]	; (80014a8 <vTaskSuspend+0x94>)
		taskENTER_CRITICAL();
 800141a:	f000 fc44 	bl	8001ca6 <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 800141e:	b904      	cbnz	r4, 8001422 <vTaskSuspend+0xe>
 8001420:	6834      	ldr	r4, [r6, #0]
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8001422:	1d25      	adds	r5, r4, #4
 8001424:	4628      	mov	r0, r5
 8001426:	f000 fdbc 	bl	8001fa2 <uxListRemove>
 800142a:	b960      	cbnz	r0, 8001446 <vTaskSuspend+0x32>
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 800142c:	2114      	movs	r1, #20
 800142e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8001430:	4b1e      	ldr	r3, [pc, #120]	; (80014ac <vTaskSuspend+0x98>)
 8001432:	4341      	muls	r1, r0
 8001434:	585b      	ldr	r3, [r3, r1]
 8001436:	b933      	cbnz	r3, 8001446 <vTaskSuspend+0x32>
 8001438:	2201      	movs	r2, #1
 800143a:	491d      	ldr	r1, [pc, #116]	; (80014b0 <vTaskSuspend+0x9c>)
 800143c:	4082      	lsls	r2, r0
 800143e:	680b      	ldr	r3, [r1, #0]
 8001440:	ea23 0302 	bic.w	r3, r3, r2
 8001444:	600b      	str	r3, [r1, #0]
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8001446:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001448:	b11b      	cbz	r3, 8001452 <vTaskSuspend+0x3e>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800144a:	f104 0018 	add.w	r0, r4, #24
 800144e:	f000 fda8 	bl	8001fa2 <uxListRemove>
			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 8001452:	4629      	mov	r1, r5
		if( xSchedulerRunning != pdFALSE )
 8001454:	4d17      	ldr	r5, [pc, #92]	; (80014b4 <vTaskSuspend+0xa0>)
			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 8001456:	4818      	ldr	r0, [pc, #96]	; (80014b8 <vTaskSuspend+0xa4>)
 8001458:	f000 fd80 	bl	8001f5c <vListInsertEnd>
		taskEXIT_CRITICAL();
 800145c:	f000 fc32 	bl	8001cc4 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
 8001460:	682a      	ldr	r2, [r5, #0]
 8001462:	b12a      	cbz	r2, 8001470 <vTaskSuspend+0x5c>
			taskENTER_CRITICAL();
 8001464:	f000 fc1f 	bl	8001ca6 <vPortEnterCritical>
				prvResetNextTaskUnblockTime();
 8001468:	f7ff fae4 	bl	8000a34 <prvResetNextTaskUnblockTime>
			taskEXIT_CRITICAL();
 800146c:	f000 fc2a 	bl	8001cc4 <vPortExitCritical>
		if( pxTCB == pxCurrentTCB )
 8001470:	6833      	ldr	r3, [r6, #0]
 8001472:	429c      	cmp	r4, r3
 8001474:	d116      	bne.n	80014a4 <vTaskSuspend+0x90>
			if( xSchedulerRunning != pdFALSE )
 8001476:	682b      	ldr	r3, [r5, #0]
 8001478:	b143      	cbz	r3, 800148c <vTaskSuspend+0x78>
				portYIELD_WITHIN_API();
 800147a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800147e:	4b0f      	ldr	r3, [pc, #60]	; (80014bc <vTaskSuspend+0xa8>)
 8001480:	601a      	str	r2, [r3, #0]
 8001482:	f3bf 8f4f 	dsb	sy
 8001486:	f3bf 8f6f 	isb	sy
 800148a:	bd70      	pop	{r4, r5, r6, pc}
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 800148c:	4a0c      	ldr	r2, [pc, #48]	; (80014c0 <vTaskSuspend+0xac>)
 800148e:	490a      	ldr	r1, [pc, #40]	; (80014b8 <vTaskSuspend+0xa4>)
 8001490:	6812      	ldr	r2, [r2, #0]
 8001492:	6809      	ldr	r1, [r1, #0]
 8001494:	4291      	cmp	r1, r2
 8001496:	d101      	bne.n	800149c <vTaskSuspend+0x88>
					pxCurrentTCB = NULL;
 8001498:	6033      	str	r3, [r6, #0]
 800149a:	bd70      	pop	{r4, r5, r6, pc}
	}
 800149c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
					vTaskSwitchContext();
 80014a0:	f7ff bf70 	b.w	8001384 <vTaskSwitchContext>
 80014a4:	bd70      	pop	{r4, r5, r6, pc}
 80014a6:	bf00      	nop
 80014a8:	20000048 	.word	0x20000048
 80014ac:	20000054 	.word	0x20000054
 80014b0:	200000cc 	.word	0x200000cc
 80014b4:	20000118 	.word	0x20000118
 80014b8:	2000011c 	.word	0x2000011c
 80014bc:	e000ed04 	.word	0xe000ed04
 80014c0:	200000b8 	.word	0x200000b8

080014c4 <vTaskPlaceOnEventList>:
{
 80014c4:	b510      	push	{r4, lr}
 80014c6:	460c      	mov	r4, r1
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80014c8:	4b05      	ldr	r3, [pc, #20]	; (80014e0 <vTaskPlaceOnEventList+0x1c>)
 80014ca:	6819      	ldr	r1, [r3, #0]
 80014cc:	3118      	adds	r1, #24
 80014ce:	f000 fd51 	bl	8001f74 <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 80014d2:	4620      	mov	r0, r4
}
 80014d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 80014d8:	2101      	movs	r1, #1
 80014da:	f7ff babd 	b.w	8000a58 <prvAddCurrentTaskToDelayedList>
 80014de:	bf00      	nop
 80014e0:	20000048 	.word	0x20000048

080014e4 <vTaskPlaceOnUnorderedEventList>:
{
 80014e4:	b510      	push	{r4, lr}
 80014e6:	4614      	mov	r4, r2
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 80014e8:	4b07      	ldr	r3, [pc, #28]	; (8001508 <vTaskPlaceOnUnorderedEventList+0x24>)
 80014ea:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
 80014ee:	681a      	ldr	r2, [r3, #0]
 80014f0:	6191      	str	r1, [r2, #24]
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80014f2:	6819      	ldr	r1, [r3, #0]
 80014f4:	3118      	adds	r1, #24
 80014f6:	f000 fd31 	bl	8001f5c <vListInsertEnd>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 80014fa:	4620      	mov	r0, r4
}
 80014fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8001500:	2101      	movs	r1, #1
 8001502:	f7ff baa9 	b.w	8000a58 <prvAddCurrentTaskToDelayedList>
 8001506:	bf00      	nop
 8001508:	20000048 	.word	0x20000048

0800150c <xTaskRemoveFromEventList>:
{
 800150c:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 800150e:	68c3      	ldr	r3, [r0, #12]
 8001510:	68dc      	ldr	r4, [r3, #12]
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8001512:	f104 0518 	add.w	r5, r4, #24
 8001516:	4628      	mov	r0, r5
 8001518:	f000 fd43 	bl	8001fa2 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800151c:	4b11      	ldr	r3, [pc, #68]	; (8001564 <xTaskRemoveFromEventList+0x58>)
 800151e:	681b      	ldr	r3, [r3, #0]
 8001520:	b9e3      	cbnz	r3, 800155c <xTaskRemoveFromEventList+0x50>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8001522:	1d25      	adds	r5, r4, #4
 8001524:	4628      	mov	r0, r5
 8001526:	f000 fd3c 	bl	8001fa2 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 800152a:	2301      	movs	r3, #1
 800152c:	490e      	ldr	r1, [pc, #56]	; (8001568 <xTaskRemoveFromEventList+0x5c>)
 800152e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001530:	6808      	ldr	r0, [r1, #0]
 8001532:	4093      	lsls	r3, r2
 8001534:	4303      	orrs	r3, r0
 8001536:	2014      	movs	r0, #20
 8001538:	600b      	str	r3, [r1, #0]
 800153a:	4629      	mov	r1, r5
 800153c:	4b0b      	ldr	r3, [pc, #44]	; (800156c <xTaskRemoveFromEventList+0x60>)
 800153e:	fb00 3002 	mla	r0, r0, r2, r3
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8001542:	f000 fd0b 	bl	8001f5c <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8001546:	4b0a      	ldr	r3, [pc, #40]	; (8001570 <xTaskRemoveFromEventList+0x64>)
 8001548:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800154a:	681b      	ldr	r3, [r3, #0]
 800154c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800154e:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
 8001550:	bf85      	ittet	hi
 8001552:	2001      	movhi	r0, #1
 8001554:	4b07      	ldrhi	r3, [pc, #28]	; (8001574 <xTaskRemoveFromEventList+0x68>)
		xReturn = pdFALSE;
 8001556:	2000      	movls	r0, #0
		xYieldPending = pdTRUE;
 8001558:	6018      	strhi	r0, [r3, #0]
}
 800155a:	bd38      	pop	{r3, r4, r5, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800155c:	4629      	mov	r1, r5
 800155e:	4806      	ldr	r0, [pc, #24]	; (8001578 <xTaskRemoveFromEventList+0x6c>)
 8001560:	e7ef      	b.n	8001542 <xTaskRemoveFromEventList+0x36>
 8001562:	bf00      	nop
 8001564:	200000c4 	.word	0x200000c4
 8001568:	200000cc 	.word	0x200000cc
 800156c:	20000054 	.word	0x20000054
 8001570:	20000048 	.word	0x20000048
 8001574:	20000148 	.word	0x20000148
 8001578:	20000104 	.word	0x20000104

0800157c <xTaskRemoveFromUnorderedEventList>:
{
 800157c:	b570      	push	{r4, r5, r6, lr}
	prvAddTaskToReadyList( pxUnblockedTCB );
 800157e:	2401      	movs	r4, #1
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
 8001580:	68c5      	ldr	r5, [r0, #12]
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 8001582:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
 8001586:	6001      	str	r1, [r0, #0]
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8001588:	1d2e      	adds	r6, r5, #4
	( void ) uxListRemove( pxEventListItem );
 800158a:	f000 fd0a 	bl	8001fa2 <uxListRemove>
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 800158e:	4630      	mov	r0, r6
 8001590:	f000 fd07 	bl	8001fa2 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
 8001594:	490c      	ldr	r1, [pc, #48]	; (80015c8 <xTaskRemoveFromUnorderedEventList+0x4c>)
 8001596:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8001598:	6808      	ldr	r0, [r1, #0]
 800159a:	fa04 f302 	lsl.w	r3, r4, r2
 800159e:	4303      	orrs	r3, r0
 80015a0:	2014      	movs	r0, #20
 80015a2:	600b      	str	r3, [r1, #0]
 80015a4:	4b09      	ldr	r3, [pc, #36]	; (80015cc <xTaskRemoveFromUnorderedEventList+0x50>)
 80015a6:	4631      	mov	r1, r6
 80015a8:	fb00 3002 	mla	r0, r0, r2, r3
 80015ac:	f000 fcd6 	bl	8001f5c <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 80015b0:	4b07      	ldr	r3, [pc, #28]	; (80015d0 <xTaskRemoveFromUnorderedEventList+0x54>)
 80015b2:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 80015b4:	681b      	ldr	r3, [r3, #0]
 80015b6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80015b8:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
 80015ba:	bf83      	ittte	hi
 80015bc:	4b05      	ldrhi	r3, [pc, #20]	; (80015d4 <xTaskRemoveFromUnorderedEventList+0x58>)
		xReturn = pdTRUE;
 80015be:	4620      	movhi	r0, r4
		xYieldPending = pdTRUE;
 80015c0:	601c      	strhi	r4, [r3, #0]
		xReturn = pdFALSE;
 80015c2:	2000      	movls	r0, #0
}
 80015c4:	bd70      	pop	{r4, r5, r6, pc}
 80015c6:	bf00      	nop
 80015c8:	200000cc 	.word	0x200000cc
 80015cc:	20000054 	.word	0x20000054
 80015d0:	20000048 	.word	0x20000048
 80015d4:	20000148 	.word	0x20000148

080015d8 <vTaskSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 80015d8:	4b03      	ldr	r3, [pc, #12]	; (80015e8 <vTaskSetTimeOutState+0x10>)
 80015da:	681b      	ldr	r3, [r3, #0]
 80015dc:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 80015de:	4b03      	ldr	r3, [pc, #12]	; (80015ec <vTaskSetTimeOutState+0x14>)
 80015e0:	681b      	ldr	r3, [r3, #0]
 80015e2:	6043      	str	r3, [r0, #4]
 80015e4:	4770      	bx	lr
 80015e6:	bf00      	nop
 80015e8:	20000100 	.word	0x20000100
 80015ec:	20000144 	.word	0x20000144

080015f0 <xTaskCheckForTimeOut>:
{
 80015f0:	b538      	push	{r3, r4, r5, lr}
 80015f2:	460d      	mov	r5, r1
 80015f4:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 80015f6:	f000 fb56 	bl	8001ca6 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
 80015fa:	4b0e      	ldr	r3, [pc, #56]	; (8001634 <xTaskCheckForTimeOut+0x44>)
			if( *pxTicksToWait == portMAX_DELAY )
 80015fc:	682a      	ldr	r2, [r5, #0]
		const TickType_t xConstTickCount = xTickCount;
 80015fe:	6818      	ldr	r0, [r3, #0]
			if( *pxTicksToWait == portMAX_DELAY )
 8001600:	1c53      	adds	r3, r2, #1
 8001602:	d010      	beq.n	8001626 <xTaskCheckForTimeOut+0x36>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8001604:	4b0c      	ldr	r3, [pc, #48]	; (8001638 <xTaskCheckForTimeOut+0x48>)
 8001606:	6821      	ldr	r1, [r4, #0]
 8001608:	681b      	ldr	r3, [r3, #0]
 800160a:	4299      	cmp	r1, r3
 800160c:	6863      	ldr	r3, [r4, #4]
 800160e:	d001      	beq.n	8001614 <xTaskCheckForTimeOut+0x24>
 8001610:	4298      	cmp	r0, r3
 8001612:	d20d      	bcs.n	8001630 <xTaskCheckForTimeOut+0x40>
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8001614:	1ac1      	subs	r1, r0, r3
 8001616:	428a      	cmp	r2, r1
 8001618:	d90a      	bls.n	8001630 <xTaskCheckForTimeOut+0x40>
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
 800161a:	1a1b      	subs	r3, r3, r0
 800161c:	4413      	add	r3, r2
 800161e:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState( pxTimeOut );
 8001620:	4620      	mov	r0, r4
 8001622:	f7ff ffd9 	bl	80015d8 <vTaskSetTimeOutState>
				xReturn = pdFALSE;
 8001626:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 8001628:	f000 fb4c 	bl	8001cc4 <vPortExitCritical>
}
 800162c:	4620      	mov	r0, r4
 800162e:	bd38      	pop	{r3, r4, r5, pc}
			xReturn = pdTRUE;
 8001630:	2401      	movs	r4, #1
 8001632:	e7f9      	b.n	8001628 <xTaskCheckForTimeOut+0x38>
 8001634:	20000144 	.word	0x20000144
 8001638:	20000100 	.word	0x20000100

0800163c <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 800163c:	2201      	movs	r2, #1
 800163e:	4b01      	ldr	r3, [pc, #4]	; (8001644 <vTaskMissedYield+0x8>)
 8001640:	601a      	str	r2, [r3, #0]
 8001642:	4770      	bx	lr
 8001644:	20000148 	.word	0x20000148

08001648 <uxTaskGetTaskNumber>:
		if( xTask != NULL )
 8001648:	b100      	cbz	r0, 800164c <uxTaskGetTaskNumber+0x4>
			uxReturn = pxTCB->uxTaskNumber;
 800164a:	6c80      	ldr	r0, [r0, #72]	; 0x48
	}
 800164c:	4770      	bx	lr

0800164e <vTaskSetTaskNumber>:
		if( xTask != NULL )
 800164e:	b100      	cbz	r0, 8001652 <vTaskSetTaskNumber+0x4>
			pxTCB->uxTaskNumber = uxHandle;
 8001650:	6481      	str	r1, [r0, #72]	; 0x48
 8001652:	4770      	bx	lr

08001654 <vTaskGetInfo>:
	{
 8001654:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001658:	460c      	mov	r4, r1
 800165a:	4617      	mov	r7, r2
 800165c:	4698      	mov	r8, r3
		pxTCB = prvGetTCBFromHandle( xTask );
 800165e:	4606      	mov	r6, r0
 8001660:	bb60      	cbnz	r0, 80016bc <vTaskGetInfo+0x68>
 8001662:	4b1b      	ldr	r3, [pc, #108]	; (80016d0 <vTaskGetInfo+0x7c>)
 8001664:	681d      	ldr	r5, [r3, #0]
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
 8001666:	f105 0334 	add.w	r3, r5, #52	; 0x34
 800166a:	6063      	str	r3, [r4, #4]
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
 800166c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
 800166e:	6025      	str	r5, [r4, #0]
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
 8001670:	6123      	str	r3, [r4, #16]
		pxTaskStatus->pxStackBase = pxTCB->pxStack;
 8001672:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8001674:	61e3      	str	r3, [r4, #28]
		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
 8001676:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8001678:	60a3      	str	r3, [r4, #8]
			if( pxTaskStatus->eCurrentState == eSuspended )
 800167a:	7b23      	ldrb	r3, [r4, #12]
 800167c:	2b03      	cmp	r3, #3
 800167e:	d107      	bne.n	8001690 <vTaskGetInfo+0x3c>
				vTaskSuspendAll();
 8001680:	f7ff fcee 	bl	8001060 <vTaskSuspendAll>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8001684:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8001686:	b10b      	cbz	r3, 800168c <vTaskGetInfo+0x38>
						pxTaskStatus->eCurrentState = eBlocked;
 8001688:	2302      	movs	r3, #2
 800168a:	7323      	strb	r3, [r4, #12]
				xTaskResumeAll();
 800168c:	f7ff fd90 	bl	80011b0 <xTaskResumeAll>
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
 8001690:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
		if( eState != eInvalid )
 8001692:	f1b8 0f05 	cmp.w	r8, #5
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
 8001696:	6163      	str	r3, [r4, #20]
			pxTaskStatus->ulRunTimeCounter = 0;
 8001698:	f04f 0300 	mov.w	r3, #0
 800169c:	61a3      	str	r3, [r4, #24]
		if( eState != eInvalid )
 800169e:	d00f      	beq.n	80016c0 <vTaskGetInfo+0x6c>
			pxTaskStatus->eCurrentState = eState;
 80016a0:	f884 800c 	strb.w	r8, [r4, #12]
		if( xGetFreeStackSpace != pdFALSE )
 80016a4:	b18f      	cbz	r7, 80016ca <vTaskGetInfo+0x76>
 80016a6:	6b29      	ldr	r1, [r5, #48]	; 0x30
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
 80016a8:	460a      	mov	r2, r1
 80016aa:	1a53      	subs	r3, r2, r1
		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 80016ac:	f812 0b01 	ldrb.w	r0, [r2], #1
 80016b0:	28a5      	cmp	r0, #165	; 0xa5
 80016b2:	d0fa      	beq.n	80016aa <vTaskGetInfo+0x56>
		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
 80016b4:	089b      	lsrs	r3, r3, #2
		return ( uint16_t ) ulCount;
 80016b6:	8423      	strh	r3, [r4, #32]
 80016b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80016bc:	4605      	mov	r5, r0
 80016be:	e7d2      	b.n	8001666 <vTaskGetInfo+0x12>
			pxTaskStatus->eCurrentState = eTaskGetState( xTask );
 80016c0:	4630      	mov	r0, r6
 80016c2:	f7ff fb55 	bl	8000d70 <eTaskGetState>
 80016c6:	7320      	strb	r0, [r4, #12]
 80016c8:	e7ec      	b.n	80016a4 <vTaskGetInfo+0x50>
			pxTaskStatus->usStackHighWaterMark = 0;
 80016ca:	8427      	strh	r7, [r4, #32]
 80016cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80016d0:	20000048 	.word	0x20000048

080016d4 <prvListTasksWithinSingleList>:
	{
 80016d4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 80016d8:	680d      	ldr	r5, [r1, #0]
	{
 80016da:	4681      	mov	r9, r0
 80016dc:	460c      	mov	r4, r1
 80016de:	4693      	mov	fp, r2
		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 80016e0:	b31d      	cbz	r5, 800172a <prvListTasksWithinSingleList+0x56>
	UBaseType_t uxTask = 0;
 80016e2:	2500      	movs	r5, #0
				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
 80016e4:	f04f 0a24 	mov.w	sl, #36	; 0x24
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 80016e8:	684b      	ldr	r3, [r1, #4]
 80016ea:	f101 0708 	add.w	r7, r1, #8
 80016ee:	685b      	ldr	r3, [r3, #4]
 80016f0:	42bb      	cmp	r3, r7
 80016f2:	604b      	str	r3, [r1, #4]
 80016f4:	bf04      	itt	eq
 80016f6:	68cb      	ldreq	r3, [r1, #12]
 80016f8:	604b      	streq	r3, [r1, #4]
 80016fa:	684b      	ldr	r3, [r1, #4]
 80016fc:	f8d3 800c 	ldr.w	r8, [r3, #12]
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 8001700:	6863      	ldr	r3, [r4, #4]
				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
 8001702:	fb0a 9105 	mla	r1, sl, r5, r9
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 8001706:	685b      	ldr	r3, [r3, #4]
				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
 8001708:	2201      	movs	r2, #1
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 800170a:	429f      	cmp	r7, r3
 800170c:	6063      	str	r3, [r4, #4]
 800170e:	bf08      	it	eq
 8001710:	68e3      	ldreq	r3, [r4, #12]
				uxTask++;
 8001712:	f105 0501 	add.w	r5, r5, #1
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 8001716:	bf08      	it	eq
 8001718:	6063      	streq	r3, [r4, #4]
 800171a:	6863      	ldr	r3, [r4, #4]
 800171c:	68de      	ldr	r6, [r3, #12]
				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
 800171e:	465b      	mov	r3, fp
 8001720:	4630      	mov	r0, r6
 8001722:	f7ff ff97 	bl	8001654 <vTaskGetInfo>
			} while( pxNextTCB != pxFirstTCB );
 8001726:	45b0      	cmp	r8, r6
 8001728:	d1ea      	bne.n	8001700 <prvListTasksWithinSingleList+0x2c>
	}
 800172a:	4628      	mov	r0, r5
 800172c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

08001730 <uxTaskGetSystemState>:
	{
 8001730:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8001734:	4605      	mov	r5, r0
 8001736:	4617      	mov	r7, r2
		vTaskSuspendAll();
 8001738:	f7ff fc92 	bl	8001060 <vTaskSuspendAll>
			if( uxArraySize >= uxCurrentNumberOfTasks )
 800173c:	4b1f      	ldr	r3, [pc, #124]	; (80017bc <uxTaskGetSystemState+0x8c>)
 800173e:	681b      	ldr	r3, [r3, #0]
 8001740:	428b      	cmp	r3, r1
 8001742:	d839      	bhi.n	80017b8 <uxTaskGetSystemState+0x88>
 8001744:	f04f 0800 	mov.w	r8, #0
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
 8001748:	2624      	movs	r6, #36	; 0x24
 800174a:	4644      	mov	r4, r8
 800174c:	f8df 9080 	ldr.w	r9, [pc, #128]	; 80017d0 <uxTaskGetSystemState+0xa0>
 8001750:	f108 0150 	add.w	r1, r8, #80	; 0x50
 8001754:	fb06 5004 	mla	r0, r6, r4, r5
 8001758:	2201      	movs	r2, #1
 800175a:	4449      	add	r1, r9
 800175c:	f7ff ffba 	bl	80016d4 <prvListTasksWithinSingleList>
 8001760:	f1a8 0814 	sub.w	r8, r8, #20
				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001764:	f118 0f64 	cmn.w	r8, #100	; 0x64
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
 8001768:	4404      	add	r4, r0
				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800176a:	d1f1      	bne.n	8001750 <uxTaskGetSystemState+0x20>
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
 800176c:	4b14      	ldr	r3, [pc, #80]	; (80017c0 <uxTaskGetSystemState+0x90>)
 800176e:	2202      	movs	r2, #2
 8001770:	6819      	ldr	r1, [r3, #0]
 8001772:	fb06 5004 	mla	r0, r6, r4, r5
 8001776:	f7ff ffad 	bl	80016d4 <prvListTasksWithinSingleList>
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
 800177a:	4b12      	ldr	r3, [pc, #72]	; (80017c4 <uxTaskGetSystemState+0x94>)
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
 800177c:	4404      	add	r4, r0
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
 800177e:	6819      	ldr	r1, [r3, #0]
 8001780:	2202      	movs	r2, #2
 8001782:	fb06 5004 	mla	r0, r6, r4, r5
 8001786:	f7ff ffa5 	bl	80016d4 <prvListTasksWithinSingleList>
 800178a:	4404      	add	r4, r0
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
 800178c:	2204      	movs	r2, #4
 800178e:	490e      	ldr	r1, [pc, #56]	; (80017c8 <uxTaskGetSystemState+0x98>)
 8001790:	fb06 5004 	mla	r0, r6, r4, r5
 8001794:	f7ff ff9e 	bl	80016d4 <prvListTasksWithinSingleList>
 8001798:	4404      	add	r4, r0
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
 800179a:	fb06 5004 	mla	r0, r6, r4, r5
 800179e:	2203      	movs	r2, #3
 80017a0:	490a      	ldr	r1, [pc, #40]	; (80017cc <uxTaskGetSystemState+0x9c>)
 80017a2:	f7ff ff97 	bl	80016d4 <prvListTasksWithinSingleList>
 80017a6:	4404      	add	r4, r0
					if( pulTotalRunTime != NULL )
 80017a8:	b10f      	cbz	r7, 80017ae <uxTaskGetSystemState+0x7e>
						*pulTotalRunTime = 0;
 80017aa:	2300      	movs	r3, #0
 80017ac:	603b      	str	r3, [r7, #0]
		( void ) xTaskResumeAll();
 80017ae:	f7ff fcff 	bl	80011b0 <xTaskResumeAll>
	}
 80017b2:	4620      	mov	r0, r4
 80017b4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 80017b8:	2400      	movs	r4, #0
 80017ba:	e7f8      	b.n	80017ae <uxTaskGetSystemState+0x7e>
 80017bc:	200000b8 	.word	0x200000b8
 80017c0:	2000004c 	.word	0x2000004c
 80017c4:	20000050 	.word	0x20000050
 80017c8:	20000130 	.word	0x20000130
 80017cc:	2000011c 	.word	0x2000011c
 80017d0:	20000054 	.word	0x20000054

080017d4 <xTaskGetCurrentTaskHandle>:
		xReturn = pxCurrentTCB;
 80017d4:	4b01      	ldr	r3, [pc, #4]	; (80017dc <xTaskGetCurrentTaskHandle+0x8>)
 80017d6:	6818      	ldr	r0, [r3, #0]
	}
 80017d8:	4770      	bx	lr
 80017da:	bf00      	nop
 80017dc:	20000048 	.word	0x20000048

080017e0 <vTaskPriorityInherit>:
	{
 80017e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		if( pxMutexHolder != NULL )
 80017e4:	4604      	mov	r4, r0
 80017e6:	2800      	cmp	r0, #0
 80017e8:	d039      	beq.n	800185e <vTaskPriorityInherit+0x7e>
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 80017ea:	4d1e      	ldr	r5, [pc, #120]	; (8001864 <vTaskPriorityInherit+0x84>)
 80017ec:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80017ee:	682a      	ldr	r2, [r5, #0]
 80017f0:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80017f2:	4293      	cmp	r3, r2
 80017f4:	d233      	bcs.n	800185e <vTaskPriorityInherit+0x7e>
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 80017f6:	2714      	movs	r7, #20
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80017f8:	6982      	ldr	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 80017fa:	4e1b      	ldr	r6, [pc, #108]	; (8001868 <vTaskPriorityInherit+0x88>)
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80017fc:	2a00      	cmp	r2, #0
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80017fe:	bfa8      	it	ge
 8001800:	682a      	ldrge	r2, [r5, #0]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8001802:	fb07 6303 	mla	r3, r7, r3, r6
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001806:	bfa2      	ittt	ge
 8001808:	6ad2      	ldrge	r2, [r2, #44]	; 0x2c
 800180a:	f1c2 0205 	rsbge	r2, r2, #5
 800180e:	6182      	strge	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8001810:	6942      	ldr	r2, [r0, #20]
 8001812:	429a      	cmp	r2, r3
 8001814:	d120      	bne.n	8001858 <vTaskPriorityInherit+0x78>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8001816:	f100 0804 	add.w	r8, r0, #4
 800181a:	4640      	mov	r0, r8
 800181c:	f000 fbc1 	bl	8001fa2 <uxListRemove>
 8001820:	4a12      	ldr	r2, [pc, #72]	; (800186c <vTaskPriorityInherit+0x8c>)
 8001822:	b948      	cbnz	r0, 8001838 <vTaskPriorityInherit+0x58>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8001824:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8001826:	4347      	muls	r7, r0
 8001828:	59f3      	ldr	r3, [r6, r7]
 800182a:	b92b      	cbnz	r3, 8001838 <vTaskPriorityInherit+0x58>
 800182c:	2101      	movs	r1, #1
 800182e:	6813      	ldr	r3, [r2, #0]
 8001830:	4081      	lsls	r1, r0
 8001832:	ea23 0301 	bic.w	r3, r3, r1
 8001836:	6013      	str	r3, [r2, #0]
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8001838:	682b      	ldr	r3, [r5, #0]
					prvAddTaskToReadyList( pxTCB );
 800183a:	6811      	ldr	r1, [r2, #0]
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 800183c:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 800183e:	2301      	movs	r3, #1
 8001840:	4083      	lsls	r3, r0
 8001842:	430b      	orrs	r3, r1
 8001844:	6013      	str	r3, [r2, #0]
 8001846:	2314      	movs	r3, #20
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8001848:	62e0      	str	r0, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 800184a:	4641      	mov	r1, r8
 800184c:	fb03 6000 	mla	r0, r3, r0, r6
	}
 8001850:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
					prvAddTaskToReadyList( pxTCB );
 8001854:	f000 bb82 	b.w	8001f5c <vListInsertEnd>
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8001858:	682b      	ldr	r3, [r5, #0]
 800185a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800185c:	62c3      	str	r3, [r0, #44]	; 0x2c
 800185e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001862:	bf00      	nop
 8001864:	20000048 	.word	0x20000048
 8001868:	20000054 	.word	0x20000054
 800186c:	200000cc 	.word	0x200000cc

08001870 <xTaskPriorityDisinherit>:
	{
 8001870:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		if( pxMutexHolder != NULL )
 8001872:	4604      	mov	r4, r0
 8001874:	b908      	cbnz	r0, 800187a <xTaskPriorityDisinherit+0xa>
	BaseType_t xReturn = pdFALSE;
 8001876:	2000      	movs	r0, #0
 8001878:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			( pxTCB->uxMutexesHeld )--;
 800187a:	6d03      	ldr	r3, [r0, #80]	; 0x50
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 800187c:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 800187e:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
			( pxTCB->uxMutexesHeld )--;
 8001880:	3b01      	subs	r3, #1
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8001882:	4291      	cmp	r1, r2
			( pxTCB->uxMutexesHeld )--;
 8001884:	6503      	str	r3, [r0, #80]	; 0x50
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8001886:	d0f6      	beq.n	8001876 <xTaskPriorityDisinherit+0x6>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 8001888:	2b00      	cmp	r3, #0
 800188a:	d1f4      	bne.n	8001876 <xTaskPriorityDisinherit+0x6>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800188c:	1d05      	adds	r5, r0, #4
 800188e:	4628      	mov	r0, r5
 8001890:	f000 fb87 	bl	8001fa2 <uxListRemove>
 8001894:	4e10      	ldr	r6, [pc, #64]	; (80018d8 <xTaskPriorityDisinherit+0x68>)
 8001896:	4a11      	ldr	r2, [pc, #68]	; (80018dc <xTaskPriorityDisinherit+0x6c>)
 8001898:	b950      	cbnz	r0, 80018b0 <xTaskPriorityDisinherit+0x40>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 800189a:	2114      	movs	r1, #20
 800189c:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 800189e:	4379      	muls	r1, r7
 80018a0:	5873      	ldr	r3, [r6, r1]
 80018a2:	b92b      	cbnz	r3, 80018b0 <xTaskPriorityDisinherit+0x40>
 80018a4:	2001      	movs	r0, #1
 80018a6:	6813      	ldr	r3, [r2, #0]
 80018a8:	40b8      	lsls	r0, r7
 80018aa:	ea23 0300 	bic.w	r3, r3, r0
 80018ae:	6013      	str	r3, [r2, #0]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 80018b0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80018b2:	f1c3 0105 	rsb	r1, r3, #5
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 80018b6:	62e3      	str	r3, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80018b8:	61a1      	str	r1, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 80018ba:	2401      	movs	r4, #1
 80018bc:	6811      	ldr	r1, [r2, #0]
 80018be:	fa04 f003 	lsl.w	r0, r4, r3
 80018c2:	4308      	orrs	r0, r1
 80018c4:	6010      	str	r0, [r2, #0]
 80018c6:	2014      	movs	r0, #20
 80018c8:	4629      	mov	r1, r5
 80018ca:	fb00 6003 	mla	r0, r0, r3, r6
 80018ce:	f000 fb45 	bl	8001f5c <vListInsertEnd>
					xReturn = pdTRUE;
 80018d2:	4620      	mov	r0, r4
	}
 80018d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80018d6:	bf00      	nop
 80018d8:	20000054 	.word	0x20000054
 80018dc:	200000cc 	.word	0x200000cc

080018e0 <uxTaskResetEventItemValue>:
	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 80018e0:	4b04      	ldr	r3, [pc, #16]	; (80018f4 <uxTaskResetEventItemValue+0x14>)
 80018e2:	681a      	ldr	r2, [r3, #0]
 80018e4:	6990      	ldr	r0, [r2, #24]
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80018e6:	681a      	ldr	r2, [r3, #0]
 80018e8:	681b      	ldr	r3, [r3, #0]
 80018ea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80018ec:	f1c3 0305 	rsb	r3, r3, #5
 80018f0:	6193      	str	r3, [r2, #24]
}
 80018f2:	4770      	bx	lr
 80018f4:	20000048 	.word	0x20000048

080018f8 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
 80018f8:	4b04      	ldr	r3, [pc, #16]	; (800190c <pvTaskIncrementMutexHeldCount+0x14>)
 80018fa:	681a      	ldr	r2, [r3, #0]
 80018fc:	b11a      	cbz	r2, 8001906 <pvTaskIncrementMutexHeldCount+0xe>
			( pxCurrentTCB->uxMutexesHeld )++;
 80018fe:	6819      	ldr	r1, [r3, #0]
 8001900:	6d0a      	ldr	r2, [r1, #80]	; 0x50
 8001902:	3201      	adds	r2, #1
 8001904:	650a      	str	r2, [r1, #80]	; 0x50
		return pxCurrentTCB;
 8001906:	6818      	ldr	r0, [r3, #0]
	}
 8001908:	4770      	bx	lr
 800190a:	bf00      	nop
 800190c:	20000048 	.word	0x20000048

08001910 <ulTaskNotifyTake>:
	{
 8001910:	b570      	push	{r4, r5, r6, lr}
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 8001912:	4c16      	ldr	r4, [pc, #88]	; (800196c <ulTaskNotifyTake+0x5c>)
	{
 8001914:	4606      	mov	r6, r0
 8001916:	460d      	mov	r5, r1
		taskENTER_CRITICAL();
 8001918:	f000 f9c5 	bl	8001ca6 <vPortEnterCritical>
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 800191c:	6823      	ldr	r3, [r4, #0]
 800191e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8001920:	b97b      	cbnz	r3, 8001942 <ulTaskNotifyTake+0x32>
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 8001922:	2101      	movs	r1, #1
 8001924:	6823      	ldr	r3, [r4, #0]
 8001926:	f883 1058 	strb.w	r1, [r3, #88]	; 0x58
				if( xTicksToWait > ( TickType_t ) 0 )
 800192a:	b155      	cbz	r5, 8001942 <ulTaskNotifyTake+0x32>
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 800192c:	4628      	mov	r0, r5
 800192e:	f7ff f893 	bl	8000a58 <prvAddCurrentTaskToDelayedList>
					portYIELD_WITHIN_API();
 8001932:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001936:	4b0e      	ldr	r3, [pc, #56]	; (8001970 <ulTaskNotifyTake+0x60>)
 8001938:	601a      	str	r2, [r3, #0]
 800193a:	f3bf 8f4f 	dsb	sy
 800193e:	f3bf 8f6f 	isb	sy
		taskEXIT_CRITICAL();
 8001942:	f000 f9bf 	bl	8001cc4 <vPortExitCritical>
		taskENTER_CRITICAL();
 8001946:	f000 f9ae 	bl	8001ca6 <vPortEnterCritical>
			ulReturn = pxCurrentTCB->ulNotifiedValue;
 800194a:	6823      	ldr	r3, [r4, #0]
 800194c:	6d5d      	ldr	r5, [r3, #84]	; 0x54
			if( ulReturn != 0UL )
 800194e:	b11d      	cbz	r5, 8001958 <ulTaskNotifyTake+0x48>
					pxCurrentTCB->ulNotifiedValue = 0UL;
 8001950:	6823      	ldr	r3, [r4, #0]
				if( xClearCountOnExit != pdFALSE )
 8001952:	b14e      	cbz	r6, 8001968 <ulTaskNotifyTake+0x58>
					pxCurrentTCB->ulNotifiedValue = 0UL;
 8001954:	2200      	movs	r2, #0
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
 8001956:	655a      	str	r2, [r3, #84]	; 0x54
			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8001958:	2200      	movs	r2, #0
 800195a:	6823      	ldr	r3, [r4, #0]
 800195c:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
		taskEXIT_CRITICAL();
 8001960:	f000 f9b0 	bl	8001cc4 <vPortExitCritical>
	}
 8001964:	4628      	mov	r0, r5
 8001966:	bd70      	pop	{r4, r5, r6, pc}
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
 8001968:	1e6a      	subs	r2, r5, #1
 800196a:	e7f4      	b.n	8001956 <ulTaskNotifyTake+0x46>
 800196c:	20000048 	.word	0x20000048
 8001970:	e000ed04 	.word	0xe000ed04

08001974 <xTaskNotifyWait>:
	{
 8001974:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 8001978:	4c1e      	ldr	r4, [pc, #120]	; (80019f4 <xTaskNotifyWait+0x80>)
	{
 800197a:	461e      	mov	r6, r3
 800197c:	4680      	mov	r8, r0
 800197e:	460f      	mov	r7, r1
 8001980:	4615      	mov	r5, r2
		taskENTER_CRITICAL();
 8001982:	f000 f990 	bl	8001ca6 <vPortEnterCritical>
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 8001986:	6823      	ldr	r3, [r4, #0]
 8001988:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 800198c:	2b02      	cmp	r3, #2
 800198e:	d014      	beq.n	80019ba <xTaskNotifyWait+0x46>
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 8001990:	2101      	movs	r1, #1
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
 8001992:	6823      	ldr	r3, [r4, #0]
 8001994:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8001996:	ea22 0208 	bic.w	r2, r2, r8
 800199a:	655a      	str	r2, [r3, #84]	; 0x54
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 800199c:	6823      	ldr	r3, [r4, #0]
 800199e:	f883 1058 	strb.w	r1, [r3, #88]	; 0x58
				if( xTicksToWait > ( TickType_t ) 0 )
 80019a2:	b156      	cbz	r6, 80019ba <xTaskNotifyWait+0x46>
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 80019a4:	4630      	mov	r0, r6
 80019a6:	f7ff f857 	bl	8000a58 <prvAddCurrentTaskToDelayedList>
					portYIELD_WITHIN_API();
 80019aa:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80019ae:	4b12      	ldr	r3, [pc, #72]	; (80019f8 <xTaskNotifyWait+0x84>)
 80019b0:	601a      	str	r2, [r3, #0]
 80019b2:	f3bf 8f4f 	dsb	sy
 80019b6:	f3bf 8f6f 	isb	sy
		taskEXIT_CRITICAL();
 80019ba:	f000 f983 	bl	8001cc4 <vPortExitCritical>
		taskENTER_CRITICAL();
 80019be:	f000 f972 	bl	8001ca6 <vPortEnterCritical>
			if( pulNotificationValue != NULL )
 80019c2:	b115      	cbz	r5, 80019ca <xTaskNotifyWait+0x56>
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
 80019c4:	6823      	ldr	r3, [r4, #0]
 80019c6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80019c8:	602b      	str	r3, [r5, #0]
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 80019ca:	6823      	ldr	r3, [r4, #0]
			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 80019cc:	2200      	movs	r2, #0
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 80019ce:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 80019d2:	2b01      	cmp	r3, #1
				xReturn = pdTRUE;
 80019d4:	bf17      	itett	ne
 80019d6:	2501      	movne	r5, #1
				xReturn = pdFALSE;
 80019d8:	2500      	moveq	r5, #0
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 80019da:	6823      	ldrne	r3, [r4, #0]
 80019dc:	6d59      	ldrne	r1, [r3, #84]	; 0x54
 80019de:	bf1c      	itt	ne
 80019e0:	43b9      	bicne	r1, r7
 80019e2:	6559      	strne	r1, [r3, #84]	; 0x54
			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 80019e4:	6823      	ldr	r3, [r4, #0]
 80019e6:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
		taskEXIT_CRITICAL();
 80019ea:	f000 f96b 	bl	8001cc4 <vPortExitCritical>
	}
 80019ee:	4628      	mov	r0, r5
 80019f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80019f4:	20000048 	.word	0x20000048
 80019f8:	e000ed04 	.word	0xe000ed04

080019fc <xTaskGenericNotify>:
	{
 80019fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80019fe:	461d      	mov	r5, r3
 8001a00:	4604      	mov	r4, r0
 8001a02:	460f      	mov	r7, r1
 8001a04:	4616      	mov	r6, r2
		taskENTER_CRITICAL();
 8001a06:	f000 f94e 	bl	8001ca6 <vPortEnterCritical>
			if( pulPreviousNotificationValue != NULL )
 8001a0a:	b10d      	cbz	r5, 8001a10 <xTaskGenericNotify+0x14>
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 8001a0c:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8001a0e:	602b      	str	r3, [r5, #0]
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 8001a10:	2302      	movs	r3, #2
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 8001a12:	f894 5058 	ldrb.w	r5, [r4, #88]	; 0x58
			switch( eAction )
 8001a16:	1e72      	subs	r2, r6, #1
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 8001a18:	b2ed      	uxtb	r5, r5
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 8001a1a:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
			switch( eAction )
 8001a1e:	2a03      	cmp	r2, #3
 8001a20:	d80a      	bhi.n	8001a38 <xTaskGenericNotify+0x3c>
 8001a22:	e8df f002 	tbb	[pc, r2]
 8001a26:	0602      	.short	0x0602
 8001a28:	1004      	.short	0x1004
					pxTCB->ulNotifiedValue |= ulValue;
 8001a2a:	6d61      	ldr	r1, [r4, #84]	; 0x54
 8001a2c:	430f      	orrs	r7, r1
						pxTCB->ulNotifiedValue = ulValue;
 8001a2e:	6567      	str	r7, [r4, #84]	; 0x54
 8001a30:	e002      	b.n	8001a38 <xTaskGenericNotify+0x3c>
					( pxTCB->ulNotifiedValue )++;
 8001a32:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8001a34:	3301      	adds	r3, #1
 8001a36:	6563      	str	r3, [r4, #84]	; 0x54
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 8001a38:	2d01      	cmp	r5, #1
 8001a3a:	d008      	beq.n	8001a4e <xTaskGenericNotify+0x52>
	{
 8001a3c:	2501      	movs	r5, #1
		taskEXIT_CRITICAL();
 8001a3e:	f000 f941 	bl	8001cc4 <vPortExitCritical>
	}
 8001a42:	4628      	mov	r0, r5
 8001a44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 8001a46:	2d02      	cmp	r5, #2
 8001a48:	d1f1      	bne.n	8001a2e <xTaskGenericNotify+0x32>
						xReturn = pdFAIL;
 8001a4a:	2500      	movs	r5, #0
 8001a4c:	e7f7      	b.n	8001a3e <xTaskGenericNotify+0x42>
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8001a4e:	1d26      	adds	r6, r4, #4
 8001a50:	4630      	mov	r0, r6
 8001a52:	f000 faa6 	bl	8001fa2 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
 8001a56:	490e      	ldr	r1, [pc, #56]	; (8001a90 <xTaskGenericNotify+0x94>)
 8001a58:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001a5a:	6808      	ldr	r0, [r1, #0]
 8001a5c:	fa05 f302 	lsl.w	r3, r5, r2
 8001a60:	4303      	orrs	r3, r0
 8001a62:	2014      	movs	r0, #20
 8001a64:	600b      	str	r3, [r1, #0]
 8001a66:	4b0b      	ldr	r3, [pc, #44]	; (8001a94 <xTaskGenericNotify+0x98>)
 8001a68:	4631      	mov	r1, r6
 8001a6a:	fb00 3002 	mla	r0, r0, r2, r3
 8001a6e:	f000 fa75 	bl	8001f5c <vListInsertEnd>
				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8001a72:	4b09      	ldr	r3, [pc, #36]	; (8001a98 <xTaskGenericNotify+0x9c>)
 8001a74:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001a76:	681b      	ldr	r3, [r3, #0]
 8001a78:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001a7a:	429a      	cmp	r2, r3
 8001a7c:	d9de      	bls.n	8001a3c <xTaskGenericNotify+0x40>
					taskYIELD_IF_USING_PREEMPTION();
 8001a7e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001a82:	4b06      	ldr	r3, [pc, #24]	; (8001a9c <xTaskGenericNotify+0xa0>)
 8001a84:	601a      	str	r2, [r3, #0]
 8001a86:	f3bf 8f4f 	dsb	sy
 8001a8a:	f3bf 8f6f 	isb	sy
 8001a8e:	e7d6      	b.n	8001a3e <xTaskGenericNotify+0x42>
 8001a90:	200000cc 	.word	0x200000cc
 8001a94:	20000054 	.word	0x20000054
 8001a98:	20000048 	.word	0x20000048
 8001a9c:	e000ed04 	.word	0xe000ed04

08001aa0 <xTaskGenericNotifyFromISR>:
	{
 8001aa0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001aa4:	9f06      	ldr	r7, [sp, #24]
 8001aa6:	4604      	mov	r4, r0
	__asm volatile
 8001aa8:	f3ef 8611 	mrs	r6, BASEPRI
 8001aac:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8001ab0:	f380 8811 	msr	BASEPRI, r0
 8001ab4:	f3bf 8f6f 	isb	sy
 8001ab8:	f3bf 8f4f 	dsb	sy
			if( pulPreviousNotificationValue != NULL )
 8001abc:	b10b      	cbz	r3, 8001ac2 <xTaskGenericNotifyFromISR+0x22>
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 8001abe:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8001ac0:	6018      	str	r0, [r3, #0]
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 8001ac2:	2302      	movs	r3, #2
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 8001ac4:	f894 5058 	ldrb.w	r5, [r4, #88]	; 0x58
			switch( eAction )
 8001ac8:	3a01      	subs	r2, #1
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 8001aca:	b2ed      	uxtb	r5, r5
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 8001acc:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
			switch( eAction )
 8001ad0:	2a03      	cmp	r2, #3
 8001ad2:	d80a      	bhi.n	8001aea <xTaskGenericNotifyFromISR+0x4a>
 8001ad4:	e8df f002 	tbb	[pc, r2]
 8001ad8:	10040602 	.word	0x10040602
					pxTCB->ulNotifiedValue |= ulValue;
 8001adc:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8001ade:	4319      	orrs	r1, r3
						pxTCB->ulNotifiedValue = ulValue;
 8001ae0:	6561      	str	r1, [r4, #84]	; 0x54
 8001ae2:	e002      	b.n	8001aea <xTaskGenericNotifyFromISR+0x4a>
					( pxTCB->ulNotifiedValue )++;
 8001ae4:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8001ae6:	3301      	adds	r3, #1
 8001ae8:	6563      	str	r3, [r4, #84]	; 0x54
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 8001aea:	2d01      	cmp	r5, #1
 8001aec:	d008      	beq.n	8001b00 <xTaskGenericNotifyFromISR+0x60>
	{
 8001aee:	2001      	movs	r0, #1
	__asm volatile
 8001af0:	f386 8811 	msr	BASEPRI, r6
	}
 8001af4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 8001af8:	2d02      	cmp	r5, #2
 8001afa:	d1f1      	bne.n	8001ae0 <xTaskGenericNotifyFromISR+0x40>
						xReturn = pdFAIL;
 8001afc:	2000      	movs	r0, #0
 8001afe:	e7f7      	b.n	8001af0 <xTaskGenericNotifyFromISR+0x50>
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8001b00:	4b12      	ldr	r3, [pc, #72]	; (8001b4c <xTaskGenericNotifyFromISR+0xac>)
 8001b02:	681b      	ldr	r3, [r3, #0]
 8001b04:	b9db      	cbnz	r3, 8001b3e <xTaskGenericNotifyFromISR+0x9e>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8001b06:	f104 0804 	add.w	r8, r4, #4
 8001b0a:	4640      	mov	r0, r8
 8001b0c:	f000 fa49 	bl	8001fa2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8001b10:	4a0f      	ldr	r2, [pc, #60]	; (8001b50 <xTaskGenericNotifyFromISR+0xb0>)
 8001b12:	2014      	movs	r0, #20
 8001b14:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001b16:	6811      	ldr	r1, [r2, #0]
 8001b18:	409d      	lsls	r5, r3
 8001b1a:	430d      	orrs	r5, r1
 8001b1c:	4641      	mov	r1, r8
 8001b1e:	6015      	str	r5, [r2, #0]
 8001b20:	4a0c      	ldr	r2, [pc, #48]	; (8001b54 <xTaskGenericNotifyFromISR+0xb4>)
 8001b22:	fb00 2003 	mla	r0, r0, r3, r2
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 8001b26:	f000 fa19 	bl	8001f5c <vListInsertEnd>
				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8001b2a:	4b0b      	ldr	r3, [pc, #44]	; (8001b58 <xTaskGenericNotifyFromISR+0xb8>)
 8001b2c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001b2e:	681b      	ldr	r3, [r3, #0]
 8001b30:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001b32:	429a      	cmp	r2, r3
 8001b34:	d9db      	bls.n	8001aee <xTaskGenericNotifyFromISR+0x4e>
 8001b36:	2001      	movs	r0, #1
					if( pxHigherPriorityTaskWoken != NULL )
 8001b38:	b12f      	cbz	r7, 8001b46 <xTaskGenericNotifyFromISR+0xa6>
						*pxHigherPriorityTaskWoken = pdTRUE;
 8001b3a:	6038      	str	r0, [r7, #0]
 8001b3c:	e7d8      	b.n	8001af0 <xTaskGenericNotifyFromISR+0x50>
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 8001b3e:	f104 0118 	add.w	r1, r4, #24
 8001b42:	4806      	ldr	r0, [pc, #24]	; (8001b5c <xTaskGenericNotifyFromISR+0xbc>)
 8001b44:	e7ef      	b.n	8001b26 <xTaskGenericNotifyFromISR+0x86>
						xYieldPending = pdTRUE;
 8001b46:	4b06      	ldr	r3, [pc, #24]	; (8001b60 <xTaskGenericNotifyFromISR+0xc0>)
 8001b48:	6018      	str	r0, [r3, #0]
 8001b4a:	e7d1      	b.n	8001af0 <xTaskGenericNotifyFromISR+0x50>
 8001b4c:	200000c4 	.word	0x200000c4
 8001b50:	200000cc 	.word	0x200000cc
 8001b54:	20000054 	.word	0x20000054
 8001b58:	20000048 	.word	0x20000048
 8001b5c:	20000104 	.word	0x20000104
 8001b60:	20000148 	.word	0x20000148

08001b64 <vTaskNotifyGiveFromISR>:
	{
 8001b64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001b68:	4604      	mov	r4, r0
 8001b6a:	460e      	mov	r6, r1
	__asm volatile
 8001b6c:	f3ef 8711 	mrs	r7, BASEPRI
 8001b70:	f04f 03bf 	mov.w	r3, #191	; 0xbf
 8001b74:	f383 8811 	msr	BASEPRI, r3
 8001b78:	f3bf 8f6f 	isb	sy
 8001b7c:	f3bf 8f4f 	dsb	sy
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 8001b80:	2302      	movs	r3, #2
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 8001b82:	f890 5058 	ldrb.w	r5, [r0, #88]	; 0x58
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 8001b86:	f880 3058 	strb.w	r3, [r0, #88]	; 0x58
			( pxTCB->ulNotifiedValue )++;
 8001b8a:	6d43      	ldr	r3, [r0, #84]	; 0x54
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 8001b8c:	b2ed      	uxtb	r5, r5
			( pxTCB->ulNotifiedValue )++;
 8001b8e:	3301      	adds	r3, #1
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 8001b90:	2d01      	cmp	r5, #1
			( pxTCB->ulNotifiedValue )++;
 8001b92:	6543      	str	r3, [r0, #84]	; 0x54
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 8001b94:	d11d      	bne.n	8001bd2 <vTaskNotifyGiveFromISR+0x6e>
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8001b96:	4b14      	ldr	r3, [pc, #80]	; (8001be8 <vTaskNotifyGiveFromISR+0x84>)
 8001b98:	681b      	ldr	r3, [r3, #0]
 8001b9a:	b9f3      	cbnz	r3, 8001bda <vTaskNotifyGiveFromISR+0x76>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8001b9c:	f100 0804 	add.w	r8, r0, #4
 8001ba0:	4640      	mov	r0, r8
 8001ba2:	f000 f9fe 	bl	8001fa2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8001ba6:	4a11      	ldr	r2, [pc, #68]	; (8001bec <vTaskNotifyGiveFromISR+0x88>)
 8001ba8:	2014      	movs	r0, #20
 8001baa:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001bac:	6811      	ldr	r1, [r2, #0]
 8001bae:	409d      	lsls	r5, r3
 8001bb0:	430d      	orrs	r5, r1
 8001bb2:	4641      	mov	r1, r8
 8001bb4:	6015      	str	r5, [r2, #0]
 8001bb6:	4a0e      	ldr	r2, [pc, #56]	; (8001bf0 <vTaskNotifyGiveFromISR+0x8c>)
 8001bb8:	fb00 2003 	mla	r0, r0, r3, r2
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 8001bbc:	f000 f9ce 	bl	8001f5c <vListInsertEnd>
				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8001bc0:	4b0c      	ldr	r3, [pc, #48]	; (8001bf4 <vTaskNotifyGiveFromISR+0x90>)
 8001bc2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001bc4:	681b      	ldr	r3, [r3, #0]
 8001bc6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001bc8:	429a      	cmp	r2, r3
 8001bca:	d902      	bls.n	8001bd2 <vTaskNotifyGiveFromISR+0x6e>
 8001bcc:	2301      	movs	r3, #1
					if( pxHigherPriorityTaskWoken != NULL )
 8001bce:	b146      	cbz	r6, 8001be2 <vTaskNotifyGiveFromISR+0x7e>
						*pxHigherPriorityTaskWoken = pdTRUE;
 8001bd0:	6033      	str	r3, [r6, #0]
	__asm volatile
 8001bd2:	f387 8811 	msr	BASEPRI, r7
 8001bd6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 8001bda:	f100 0118 	add.w	r1, r0, #24
 8001bde:	4806      	ldr	r0, [pc, #24]	; (8001bf8 <vTaskNotifyGiveFromISR+0x94>)
 8001be0:	e7ec      	b.n	8001bbc <vTaskNotifyGiveFromISR+0x58>
						xYieldPending = pdTRUE;
 8001be2:	4a06      	ldr	r2, [pc, #24]	; (8001bfc <vTaskNotifyGiveFromISR+0x98>)
 8001be4:	6013      	str	r3, [r2, #0]
 8001be6:	e7f4      	b.n	8001bd2 <vTaskNotifyGiveFromISR+0x6e>
 8001be8:	200000c4 	.word	0x200000c4
 8001bec:	200000cc 	.word	0x200000cc
 8001bf0:	20000054 	.word	0x20000054
 8001bf4:	20000048 	.word	0x20000048
 8001bf8:	20000104 	.word	0x20000104
 8001bfc:	20000148 	.word	0x20000148

08001c00 <xTaskNotifyStateClear>:
	{
 8001c00:	b510      	push	{r4, lr}
		pxTCB = prvGetTCBFromHandle( xTask );
 8001c02:	b980      	cbnz	r0, 8001c26 <xTaskNotifyStateClear+0x26>
 8001c04:	4b09      	ldr	r3, [pc, #36]	; (8001c2c <xTaskNotifyStateClear+0x2c>)
 8001c06:	681c      	ldr	r4, [r3, #0]
		taskENTER_CRITICAL();
 8001c08:	f000 f84d 	bl	8001ca6 <vPortEnterCritical>
 8001c0c:	2000      	movs	r0, #0
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
 8001c0e:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
 8001c12:	2b02      	cmp	r3, #2
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8001c14:	bf0a      	itet	eq
 8001c16:	f884 0058 	strbeq.w	r0, [r4, #88]	; 0x58
				xReturn = pdFAIL;
 8001c1a:	4604      	movne	r4, r0
				xReturn = pdPASS;
 8001c1c:	2401      	moveq	r4, #1
		taskEXIT_CRITICAL();
 8001c1e:	f000 f851 	bl	8001cc4 <vPortExitCritical>
	}
 8001c22:	4620      	mov	r0, r4
 8001c24:	bd10      	pop	{r4, pc}
 8001c26:	4604      	mov	r4, r0
 8001c28:	e7ee      	b.n	8001c08 <xTaskNotifyStateClear+0x8>
 8001c2a:	bf00      	nop
 8001c2c:	20000048 	.word	0x20000048

08001c30 <prvTaskExitError>:
	__asm volatile
 8001c30:	f04f 03bf 	mov.w	r3, #191	; 0xbf
 8001c34:	f383 8811 	msr	BASEPRI, r3
 8001c38:	f3bf 8f6f 	isb	sy
 8001c3c:	f3bf 8f4f 	dsb	sy
 8001c40:	e7fe      	b.n	8001c40 <prvTaskExitError+0x10>

08001c42 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 8001c42:	4855      	ldr	r0, [pc, #340]	; (8001d98 <xPortStartScheduler+0x30>)
 8001c44:	6800      	ldr	r0, [r0, #0]
 8001c46:	6800      	ldr	r0, [r0, #0]
 8001c48:	f380 8808 	msr	MSP, r0
 8001c4c:	b662      	cpsie	i
 8001c4e:	b661      	cpsie	f
 8001c50:	f3bf 8f4f 	dsb	sy
 8001c54:	f3bf 8f6f 	isb	sy
 8001c58:	df00      	svc	0
 8001c5a:	bf00      	nop

08001c5c <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8001c5c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8001c60:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8001c64:	4b05      	ldr	r3, [pc, #20]	; (8001c7c <pxPortInitialiseStack+0x20>)
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 8001c66:	f021 0101 	bic.w	r1, r1, #1
 8001c6a:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8001c6e:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8001c72:	f840 2c20 	str.w	r2, [r0, #-32]
}
 8001c76:	3840      	subs	r0, #64	; 0x40
 8001c78:	4770      	bx	lr
 8001c7a:	bf00      	nop
 8001c7c:	08001c31 	.word	0x08001c31

08001c80 <vPortSVCHandler>:
	__asm volatile (
 8001c80:	4b07      	ldr	r3, [pc, #28]	; (8001ca0 <pxCurrentTCBConst2>)
 8001c82:	6819      	ldr	r1, [r3, #0]
 8001c84:	6808      	ldr	r0, [r1, #0]
 8001c86:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8001c8a:	f380 8809 	msr	PSP, r0
 8001c8e:	f3bf 8f6f 	isb	sy
 8001c92:	f04f 0000 	mov.w	r0, #0
 8001c96:	f380 8811 	msr	BASEPRI, r0
 8001c9a:	f04e 0e0d 	orr.w	lr, lr, #13
 8001c9e:	4770      	bx	lr

08001ca0 <pxCurrentTCBConst2>:
 8001ca0:	20000048 	.word	0x20000048

08001ca4 <vPortEndScheduler>:
	return 0;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 8001ca4:	4770      	bx	lr

08001ca6 <vPortEnterCritical>:
 8001ca6:	f04f 03bf 	mov.w	r3, #191	; 0xbf
 8001caa:	f383 8811 	msr	BASEPRI, r3
 8001cae:	f3bf 8f6f 	isb	sy
 8001cb2:	f3bf 8f4f 	dsb	sy
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
 8001cb6:	4a02      	ldr	r2, [pc, #8]	; (8001cc0 <vPortEnterCritical+0x1a>)
 8001cb8:	6813      	ldr	r3, [r2, #0]
 8001cba:	3301      	adds	r3, #1
 8001cbc:	6013      	str	r3, [r2, #0]
 8001cbe:	4770      	bx	lr
 8001cc0:	20000028 	.word	0x20000028

08001cc4 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
	uxCriticalNesting--;
 8001cc4:	4a03      	ldr	r2, [pc, #12]	; (8001cd4 <vPortExitCritical+0x10>)
 8001cc6:	6813      	ldr	r3, [r2, #0]
 8001cc8:	3b01      	subs	r3, #1
 8001cca:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8001ccc:	b90b      	cbnz	r3, 8001cd2 <vPortExitCritical+0xe>
	__asm volatile
 8001cce:	f383 8811 	msr	BASEPRI, r3
 8001cd2:	4770      	bx	lr
 8001cd4:	20000028 	.word	0x20000028

08001cd8 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8001cd8:	f3ef 8009 	mrs	r0, PSP
 8001cdc:	f3bf 8f6f 	isb	sy
 8001ce0:	4b0f      	ldr	r3, [pc, #60]	; (8001d20 <pxCurrentTCBConst>)
 8001ce2:	681a      	ldr	r2, [r3, #0]
 8001ce4:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8001ce8:	6010      	str	r0, [r2, #0]
 8001cea:	e92d 4008 	stmdb	sp!, {r3, lr}
 8001cee:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8001cf2:	f380 8811 	msr	BASEPRI, r0
 8001cf6:	f7ff fb45 	bl	8001384 <vTaskSwitchContext>
 8001cfa:	f04f 0000 	mov.w	r0, #0
 8001cfe:	f380 8811 	msr	BASEPRI, r0
 8001d02:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8001d06:	6819      	ldr	r1, [r3, #0]
 8001d08:	6808      	ldr	r0, [r1, #0]
 8001d0a:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8001d0e:	f380 8809 	msr	PSP, r0
 8001d12:	f3bf 8f6f 	isb	sy
 8001d16:	4770      	bx	lr
 8001d18:	f3af 8000 	nop.w
 8001d1c:	f3af 8000 	nop.w

08001d20 <pxCurrentTCBConst>:
 8001d20:	20000048 	.word	0x20000048

08001d24 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8001d24:	b508      	push	{r3, lr}
	__asm volatile
 8001d26:	f04f 03bf 	mov.w	r3, #191	; 0xbf
 8001d2a:	f383 8811 	msr	BASEPRI, r3
 8001d2e:	f3bf 8f6f 	isb	sy
 8001d32:	f3bf 8f4f 	dsb	sy
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 8001d36:	f7ff f9b5 	bl	80010a4 <xTaskIncrementTick>
 8001d3a:	b118      	cbz	r0, 8001d44 <xPortSysTickHandler+0x20>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8001d3c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001d40:	4b02      	ldr	r3, [pc, #8]	; (8001d4c <xPortSysTickHandler+0x28>)
 8001d42:	601a      	str	r2, [r3, #0]
	__asm volatile
 8001d44:	2300      	movs	r3, #0
 8001d46:	f383 8811 	msr	BASEPRI, r3
 8001d4a:	bd08      	pop	{r3, pc}
 8001d4c:	e000ed04 	.word	0xe000ed04

08001d50 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8001d50:	4a03      	ldr	r2, [pc, #12]	; (8001d60 <vPortSetupTimerInterrupt+0x10>)
 8001d52:	4b04      	ldr	r3, [pc, #16]	; (8001d64 <vPortSetupTimerInterrupt+0x14>)
 8001d54:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8001d56:	2207      	movs	r2, #7
 8001d58:	f843 2c04 	str.w	r2, [r3, #-4]
 8001d5c:	4770      	bx	lr
 8001d5e:	bf00      	nop
 8001d60:	0001193f 	.word	0x0001193f
 8001d64:	e000e014 	.word	0xe000e014

08001d68 <xPortStartScheduler>:
{
 8001d68:	b508      	push	{r3, lr}
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8001d6a:	4b09      	ldr	r3, [pc, #36]	; (8001d90 <xPortStartScheduler+0x28>)
 8001d6c:	681a      	ldr	r2, [r3, #0]
 8001d6e:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
 8001d72:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8001d74:	681a      	ldr	r2, [r3, #0]
 8001d76:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
 8001d7a:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
 8001d7c:	f7ff ffe8 	bl	8001d50 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 8001d80:	2200      	movs	r2, #0
 8001d82:	4b04      	ldr	r3, [pc, #16]	; (8001d94 <xPortStartScheduler+0x2c>)
 8001d84:	601a      	str	r2, [r3, #0]
	prvPortStartFirstTask();
 8001d86:	f7ff ff5c 	bl	8001c42 <prvPortStartFirstTask>
	prvTaskExitError();
 8001d8a:	f7ff ff51 	bl	8001c30 <prvTaskExitError>
 8001d8e:	bf00      	nop
 8001d90:	e000ed20 	.word	0xe000ed20
 8001d94:	20000028 	.word	0x20000028
 8001d98:	e000ed08 	.word	0xe000ed08

08001d9c <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 8001d9c:	b510      	push	{r4, lr}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8001d9e:	4b0f      	ldr	r3, [pc, #60]	; (8001ddc <prvInsertBlockIntoFreeList+0x40>)
 8001da0:	681a      	ldr	r2, [r3, #0]
 8001da2:	4282      	cmp	r2, r0
 8001da4:	d318      	bcc.n	8001dd8 <prvInsertBlockIntoFreeList+0x3c>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8001da6:	685c      	ldr	r4, [r3, #4]
 8001da8:	1919      	adds	r1, r3, r4
 8001daa:	4288      	cmp	r0, r1
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8001dac:	bf01      	itttt	eq
 8001dae:	6841      	ldreq	r1, [r0, #4]
 8001db0:	4618      	moveq	r0, r3
 8001db2:	1909      	addeq	r1, r1, r4
 8001db4:	6059      	streq	r1, [r3, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8001db6:	6844      	ldr	r4, [r0, #4]
 8001db8:	1901      	adds	r1, r0, r4
 8001dba:	428a      	cmp	r2, r1
 8001dbc:	d107      	bne.n	8001dce <prvInsertBlockIntoFreeList+0x32>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 8001dbe:	4908      	ldr	r1, [pc, #32]	; (8001de0 <prvInsertBlockIntoFreeList+0x44>)
 8001dc0:	6809      	ldr	r1, [r1, #0]
 8001dc2:	428a      	cmp	r2, r1
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8001dc4:	bf1f      	itttt	ne
 8001dc6:	6851      	ldrne	r1, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8001dc8:	6812      	ldrne	r2, [r2, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8001dca:	1909      	addne	r1, r1, r4
 8001dcc:	6041      	strne	r1, [r0, #4]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 8001dce:	4298      	cmp	r0, r3
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8001dd0:	6002      	str	r2, [r0, #0]
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8001dd2:	bf18      	it	ne
 8001dd4:	6018      	strne	r0, [r3, #0]
 8001dd6:	bd10      	pop	{r4, pc}
 8001dd8:	4613      	mov	r3, r2
 8001dda:	e7e1      	b.n	8001da0 <prvInsertBlockIntoFreeList+0x4>
 8001ddc:	2000495c 	.word	0x2000495c
 8001de0:	2000014c 	.word	0x2000014c

08001de4 <pvPortMalloc>:
{
 8001de4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001de8:	4604      	mov	r4, r0
	vTaskSuspendAll();
 8001dea:	f7ff f939 	bl	8001060 <vTaskSuspendAll>
		if( pxEnd == NULL )
 8001dee:	4934      	ldr	r1, [pc, #208]	; (8001ec0 <pvPortMalloc+0xdc>)
 8001df0:	4d34      	ldr	r5, [pc, #208]	; (8001ec4 <pvPortMalloc+0xe0>)
 8001df2:	680b      	ldr	r3, [r1, #0]
 8001df4:	bb0b      	cbnz	r3, 8001e3a <pvPortMalloc+0x56>
	uxAddress = ( size_t ) ucHeap;
 8001df6:	4a34      	ldr	r2, [pc, #208]	; (8001ec8 <pvPortMalloc+0xe4>)
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8001df8:	4e34      	ldr	r6, [pc, #208]	; (8001ecc <pvPortMalloc+0xe8>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8001dfa:	0750      	lsls	r0, r2, #29
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 8001dfc:	bf1d      	ittte	ne
 8001dfe:	1dd0      	addne	r0, r2, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8001e00:	f020 0007 	bicne.w	r0, r0, #7
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 8001e04:	f502 4390 	addne.w	r3, r2, #18432	; 0x4800
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 8001e08:	f44f 4390 	moveq.w	r3, #18432	; 0x4800
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8001e0c:	bf1c      	itt	ne
 8001e0e:	4602      	movne	r2, r0
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 8001e10:	1a1b      	subne	r3, r3, r0
	xStart.xBlockSize = ( size_t ) 0;
 8001e12:	2000      	movs	r0, #0
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 8001e14:	4413      	add	r3, r2
	uxAddress -= xHeapStructSize;
 8001e16:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8001e18:	f023 0307 	bic.w	r3, r3, #7
	xStart.xBlockSize = ( size_t ) 0;
 8001e1c:	6070      	str	r0, [r6, #4]
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8001e1e:	6032      	str	r2, [r6, #0]
	pxEnd->xBlockSize = 0;
 8001e20:	6058      	str	r0, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 8001e22:	6018      	str	r0, [r3, #0]
	pxEnd = ( void * ) uxAddress;
 8001e24:	600b      	str	r3, [r1, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8001e26:	1a98      	subs	r0, r3, r2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 8001e28:	6013      	str	r3, [r2, #0]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8001e2a:	4b29      	ldr	r3, [pc, #164]	; (8001ed0 <pvPortMalloc+0xec>)
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8001e2c:	6050      	str	r0, [r2, #4]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8001e2e:	6018      	str	r0, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8001e30:	4b28      	ldr	r3, [pc, #160]	; (8001ed4 <pvPortMalloc+0xf0>)
 8001e32:	6018      	str	r0, [r3, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8001e34:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 8001e38:	602b      	str	r3, [r5, #0]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8001e3a:	682f      	ldr	r7, [r5, #0]
 8001e3c:	4227      	tst	r7, r4
 8001e3e:	d116      	bne.n	8001e6e <pvPortMalloc+0x8a>
			if( xWantedSize > 0 )
 8001e40:	2c00      	cmp	r4, #0
 8001e42:	d037      	beq.n	8001eb4 <pvPortMalloc+0xd0>
				xWantedSize += xHeapStructSize;
 8001e44:	f104 0308 	add.w	r3, r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8001e48:	075a      	lsls	r2, r3, #29
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8001e4a:	bf1c      	itt	ne
 8001e4c:	f023 0307 	bicne.w	r3, r3, #7
 8001e50:	3308      	addne	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8001e52:	b163      	cbz	r3, 8001e6e <pvPortMalloc+0x8a>
 8001e54:	4a1f      	ldr	r2, [pc, #124]	; (8001ed4 <pvPortMalloc+0xf0>)
 8001e56:	6816      	ldr	r6, [r2, #0]
 8001e58:	4690      	mov	r8, r2
 8001e5a:	42b3      	cmp	r3, r6
 8001e5c:	d807      	bhi.n	8001e6e <pvPortMalloc+0x8a>
				pxBlock = xStart.pxNextFreeBlock;
 8001e5e:	4a1b      	ldr	r2, [pc, #108]	; (8001ecc <pvPortMalloc+0xe8>)
 8001e60:	6815      	ldr	r5, [r2, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8001e62:	6868      	ldr	r0, [r5, #4]
 8001e64:	4283      	cmp	r3, r0
 8001e66:	d804      	bhi.n	8001e72 <pvPortMalloc+0x8e>
				if( pxBlock != pxEnd )
 8001e68:	6809      	ldr	r1, [r1, #0]
 8001e6a:	428d      	cmp	r5, r1
 8001e6c:	d107      	bne.n	8001e7e <pvPortMalloc+0x9a>
void *pvReturn = NULL;
 8001e6e:	2400      	movs	r4, #0
 8001e70:	e020      	b.n	8001eb4 <pvPortMalloc+0xd0>
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8001e72:	682c      	ldr	r4, [r5, #0]
 8001e74:	2c00      	cmp	r4, #0
 8001e76:	d0f7      	beq.n	8001e68 <pvPortMalloc+0x84>
 8001e78:	462a      	mov	r2, r5
 8001e7a:	4625      	mov	r5, r4
 8001e7c:	e7f1      	b.n	8001e62 <pvPortMalloc+0x7e>
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8001e7e:	6829      	ldr	r1, [r5, #0]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8001e80:	6814      	ldr	r4, [r2, #0]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8001e82:	6011      	str	r1, [r2, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8001e84:	1ac2      	subs	r2, r0, r3
 8001e86:	2a10      	cmp	r2, #16
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8001e88:	f104 0408 	add.w	r4, r4, #8
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8001e8c:	d904      	bls.n	8001e98 <pvPortMalloc+0xb4>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 8001e8e:	18e8      	adds	r0, r5, r3
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8001e90:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 8001e92:	606b      	str	r3, [r5, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 8001e94:	f7ff ff82 	bl	8001d9c <prvInsertBlockIntoFreeList>
					pxBlock->pxNextFreeBlock = NULL;
 8001e98:	2300      	movs	r3, #0
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8001e9a:	490d      	ldr	r1, [pc, #52]	; (8001ed0 <pvPortMalloc+0xec>)
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8001e9c:	686a      	ldr	r2, [r5, #4]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8001e9e:	6808      	ldr	r0, [r1, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8001ea0:	1ab6      	subs	r6, r6, r2
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8001ea2:	4286      	cmp	r6, r0
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8001ea4:	ea47 0702 	orr.w	r7, r7, r2
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8001ea8:	f8c8 6000 	str.w	r6, [r8]
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8001eac:	bf38      	it	cc
 8001eae:	600e      	strcc	r6, [r1, #0]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8001eb0:	606f      	str	r7, [r5, #4]
					pxBlock->pxNextFreeBlock = NULL;
 8001eb2:	602b      	str	r3, [r5, #0]
	( void ) xTaskResumeAll();
 8001eb4:	f7ff f97c 	bl	80011b0 <xTaskResumeAll>
}
 8001eb8:	4620      	mov	r0, r4
 8001eba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001ebe:	bf00      	nop
 8001ec0:	2000014c 	.word	0x2000014c
 8001ec4:	20004950 	.word	0x20004950
 8001ec8:	20000150 	.word	0x20000150
 8001ecc:	2000495c 	.word	0x2000495c
 8001ed0:	20004958 	.word	0x20004958
 8001ed4:	20004954 	.word	0x20004954

08001ed8 <vPortFree>:
{
 8001ed8:	b510      	push	{r4, lr}
	if( pv != NULL )
 8001eda:	4604      	mov	r4, r0
 8001edc:	b1e0      	cbz	r0, 8001f18 <vPortFree+0x40>
		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
 8001ede:	4a0f      	ldr	r2, [pc, #60]	; (8001f1c <vPortFree+0x44>)
 8001ee0:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8001ee4:	6812      	ldr	r2, [r2, #0]
 8001ee6:	4213      	tst	r3, r2
 8001ee8:	d016      	beq.n	8001f18 <vPortFree+0x40>
			if( pxLink->pxNextFreeBlock == NULL )
 8001eea:	f850 1c08 	ldr.w	r1, [r0, #-8]
 8001eee:	b999      	cbnz	r1, 8001f18 <vPortFree+0x40>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8001ef0:	ea23 0302 	bic.w	r3, r3, r2
 8001ef4:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
 8001ef8:	f7ff f8b2 	bl	8001060 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 8001efc:	4a08      	ldr	r2, [pc, #32]	; (8001f20 <vPortFree+0x48>)
 8001efe:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8001f02:	6811      	ldr	r1, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8001f04:	f1a4 0008 	sub.w	r0, r4, #8
					xFreeBytesRemaining += pxLink->xBlockSize;
 8001f08:	440b      	add	r3, r1
 8001f0a:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8001f0c:	f7ff ff46 	bl	8001d9c <prvInsertBlockIntoFreeList>
}
 8001f10:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				( void ) xTaskResumeAll();
 8001f14:	f7ff b94c 	b.w	80011b0 <xTaskResumeAll>
 8001f18:	bd10      	pop	{r4, pc}
 8001f1a:	bf00      	nop
 8001f1c:	20004950 	.word	0x20004950
 8001f20:	20004954 	.word	0x20004954

08001f24 <xPortGetFreeHeapSize>:
}
 8001f24:	4b01      	ldr	r3, [pc, #4]	; (8001f2c <xPortGetFreeHeapSize+0x8>)
 8001f26:	6818      	ldr	r0, [r3, #0]
 8001f28:	4770      	bx	lr
 8001f2a:	bf00      	nop
 8001f2c:	20004954 	.word	0x20004954

08001f30 <xPortGetMinimumEverFreeHeapSize>:
}
 8001f30:	4b01      	ldr	r3, [pc, #4]	; (8001f38 <xPortGetMinimumEverFreeHeapSize+0x8>)
 8001f32:	6818      	ldr	r0, [r3, #0]
 8001f34:	4770      	bx	lr
 8001f36:	bf00      	nop
 8001f38:	20004958 	.word	0x20004958

08001f3c <vPortInitialiseBlocks>:
{
 8001f3c:	4770      	bx	lr
 8001f3e:	bf00      	nop

08001f40 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8001f40:	f100 0308 	add.w	r3, r0, #8
 8001f44:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8001f46:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8001f4a:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8001f4c:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8001f4e:	2300      	movs	r3, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8001f50:	6082      	str	r2, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8001f52:	6003      	str	r3, [r0, #0]
 8001f54:	4770      	bx	lr

08001f56 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8001f56:	2300      	movs	r3, #0
 8001f58:	6103      	str	r3, [r0, #16]
 8001f5a:	4770      	bx	lr

08001f5c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8001f5c:	6843      	ldr	r3, [r0, #4]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8001f5e:	689a      	ldr	r2, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
 8001f60:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8001f62:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8001f64:	689a      	ldr	r2, [r3, #8]
 8001f66:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8001f68:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8001f6a:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 8001f6c:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8001f6e:	3301      	adds	r3, #1
 8001f70:	6003      	str	r3, [r0, #0]
 8001f72:	4770      	bx	lr

08001f74 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8001f74:	680a      	ldr	r2, [r1, #0]
{
 8001f76:	b530      	push	{r4, r5, lr}
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8001f78:	1c53      	adds	r3, r2, #1
 8001f7a:	d10a      	bne.n	8001f92 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8001f7c:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8001f7e:	685a      	ldr	r2, [r3, #4]
 8001f80:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8001f82:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8001f84:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 8001f86:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8001f88:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 8001f8a:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8001f8c:	3301      	adds	r3, #1
 8001f8e:	6003      	str	r3, [r0, #0]
 8001f90:	bd30      	pop	{r4, r5, pc}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8001f92:	f100 0308 	add.w	r3, r0, #8
 8001f96:	685c      	ldr	r4, [r3, #4]
 8001f98:	6825      	ldr	r5, [r4, #0]
 8001f9a:	42aa      	cmp	r2, r5
 8001f9c:	d3ef      	bcc.n	8001f7e <vListInsert+0xa>
 8001f9e:	4623      	mov	r3, r4
 8001fa0:	e7f9      	b.n	8001f96 <vListInsert+0x22>

08001fa2 <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8001fa2:	6841      	ldr	r1, [r0, #4]
 8001fa4:	6882      	ldr	r2, [r0, #8]
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8001fa6:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8001fa8:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8001faa:	6882      	ldr	r2, [r0, #8]
 8001fac:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8001fae:	6859      	ldr	r1, [r3, #4]
 8001fb0:	4288      	cmp	r0, r1
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8001fb2:	bf08      	it	eq
 8001fb4:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8001fb6:	2200      	movs	r2, #0
 8001fb8:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8001fba:	6818      	ldr	r0, [r3, #0]
 8001fbc:	3801      	subs	r0, #1
 8001fbe:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
 8001fc0:	4770      	bx	lr
	...

08001fc4 <main>:
  xTaskCreate( task1, "led1", 1024, ( void * ) NULL, 0, NULL );
 8001fc4:	2400      	movs	r4, #0
{
 8001fc6:	b507      	push	{r0, r1, r2, lr}
  prvSetupHardware();
 8001fc8:	f7fe f90f 	bl	80001ea <prvSetupHardware>
  xTaskCreate( task1, "led1", 1024, ( void * ) NULL, 0, NULL );
 8001fcc:	4623      	mov	r3, r4
 8001fce:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8001fd2:	4909      	ldr	r1, [pc, #36]	; (8001ff8 <main+0x34>)
 8001fd4:	9401      	str	r4, [sp, #4]
 8001fd6:	9400      	str	r4, [sp, #0]
 8001fd8:	4808      	ldr	r0, [pc, #32]	; (8001ffc <main+0x38>)
 8001fda:	f7fe fd83 	bl	8000ae4 <xTaskCreate>
  xTaskCreate( task2, "led2", 1024, ( void * ) NULL, 0, NULL );
 8001fde:	4623      	mov	r3, r4
 8001fe0:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8001fe4:	4906      	ldr	r1, [pc, #24]	; (8002000 <main+0x3c>)
 8001fe6:	9401      	str	r4, [sp, #4]
 8001fe8:	9400      	str	r4, [sp, #0]
 8001fea:	4806      	ldr	r0, [pc, #24]	; (8002004 <main+0x40>)
 8001fec:	f7fe fd7a 	bl	8000ae4 <xTaskCreate>
  vTaskStartScheduler();
 8001ff0:	f7fe fff6 	bl	8000fe0 <vTaskStartScheduler>
 8001ff4:	e7fe      	b.n	8001ff4 <main+0x30>
 8001ff6:	bf00      	nop
 8001ff8:	08002078 	.word	0x08002078
 8001ffc:	0800017d 	.word	0x0800017d
 8002000:	0800207d 	.word	0x0800207d
 8002004:	080001a9 	.word	0x080001a9

08002008 <Reset_Handler>:
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:	

/* Copy the data segment initializers from flash to SRAM */  
  movs	r1, #0
 8002008:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 800200a:	e003      	b.n	8002014 <LoopCopyDataInit>

0800200c <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 800200c:	4b0a      	ldr	r3, [pc, #40]	; (8002038 <LoopFillZerobss+0x10>)
	ldr	r3, [r3, r1]
 800200e:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 8002010:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 8002012:	3104      	adds	r1, #4

08002014 <LoopCopyDataInit>:
    
LoopCopyDataInit:
	ldr	r0, =_sdata
 8002014:	4809      	ldr	r0, [pc, #36]	; (800203c <LoopFillZerobss+0x14>)
	ldr	r3, =_edata
 8002016:	4b0a      	ldr	r3, [pc, #40]	; (8002040 <LoopFillZerobss+0x18>)
	adds	r2, r0, r1
 8002018:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 800201a:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 800201c:	d3f6      	bcc.n	800200c <CopyDataInit>
	ldr	r2, =_sbss
 800201e:	4a09      	ldr	r2, [pc, #36]	; (8002044 <LoopFillZerobss+0x1c>)
	b	LoopFillZerobss
 8002020:	e002      	b.n	8002028 <LoopFillZerobss>

08002022 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
	movs	r3, #0
 8002022:	2300      	movs	r3, #0
	str	r3, [r2], #4
 8002024:	f842 3b04 	str.w	r3, [r2], #4

08002028 <LoopFillZerobss>:
    
LoopFillZerobss:
	ldr	r3, = _ebss
 8002028:	4b07      	ldr	r3, [pc, #28]	; (8002048 <LoopFillZerobss+0x20>)
	cmp	r2, r3
 800202a:	429a      	cmp	r2, r3
	bcc	FillZerobss
 800202c:	d3f9      	bcc.n	8002022 <FillZerobss>
/* Call the clock system intitialization function.*/
  bl  SystemInit 	
 800202e:	f7fe fc49 	bl	80008c4 <SystemInit>
/* Call the application's entry point.*/
	bl	main
 8002032:	f7ff ffc7 	bl	8001fc4 <main>
	bx	lr    
 8002036:	4770      	bx	lr
	ldr	r3, =_sidata
 8002038:	08002090 	.word	0x08002090
	ldr	r0, =_sdata
 800203c:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 8002040:	2000002c 	.word	0x2000002c
	ldr	r2, =_sbss
 8002044:	2000002c 	.word	0x2000002c
	ldr	r3, = _ebss
 8002048:	2000496c 	.word	0x2000496c

0800204c <ADC1_2_IRQHandler>:
 * @retval None       
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 800204c:	e7fe      	b.n	800204c <ADC1_2_IRQHandler>

0800204e <memset>:
 800204e:	4603      	mov	r3, r0
 8002050:	4402      	add	r2, r0
 8002052:	4293      	cmp	r3, r2
 8002054:	d100      	bne.n	8002058 <memset+0xa>
 8002056:	4770      	bx	lr
 8002058:	f803 1b01 	strb.w	r1, [r3], #1
 800205c:	e7f9      	b.n	8002052 <memset+0x4>
	...

08002060 <_init>:
 8002060:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002062:	bf00      	nop
 8002064:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002066:	bc08      	pop	{r3}
 8002068:	469e      	mov	lr, r3
 800206a:	4770      	bx	lr

0800206c <_fini>:
 800206c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800206e:	bf00      	nop
 8002070:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002072:	bc08      	pop	{r3}
 8002074:	469e      	mov	lr, r3
 8002076:	4770      	bx	lr
